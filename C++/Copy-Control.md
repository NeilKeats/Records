# 拷贝控制

显式/隐式地指定对象拷贝、移动、赋值和销毁

# 拷贝/赋值/销毁

| 拷贝控制操作 copy control:                  | **场景类型** |      |
| :------------------------------------ | :------: | ---- |
| **拷贝构造函数**（copy constructor）          |   初始化    |      |
| **拷贝赋值运算符**（copy-assignment operator） |    赋值    |      |
| **移动构造函数**（move constructor）          |   初始化    |      |
| **移动赋值运算符**（move-assignment operator） |    赋值    |      |
| **析构函数**（destructor）                  |   销毁对象   |      |

## 拷贝构造函数

第一个参数必须是引用类型，虽然也可以接受非const引用的拷贝构造函数，但一般都是const。

合成拷贝构造函数（synthesized copy constructor），是编译器定义的构造函数。将非static成员拷贝到正在创建的对象中。对于数组类型，会逐个元素地拷贝（虽然数组无法赋值）。

**拷贝与初始化**

回顾一下直接初始化与拷贝初始化。

```c++
string dots(10,'.');			//直接初始化
string s(dots);					//直接初始化

string s2 = dots;				//拷贝初始化
string null_book = "9_999_9";	//拷贝初始化
string nines = string(100,'9');	//拷贝初始化
```

-   使用**直接初始化**时，要求编译器使用普通的函数匹配，来选择参数最匹配的构造函数。
-   使用**拷贝初始化**时，要求将右侧对象拷贝到正在创建的对象（可能隐含类型转换）。拷贝初始化，通常使用**拷贝构造函数**，也可能使用**移动构造函数**。
    -   使用`=`定义变量
    -   将对象作为实参传递给一个非引用类型的形参。【因此拷贝构造参数必须为引用，否则无限调用自己】
    -   从一个返回类型为非引用类型的函数返回一个对象
    -   花括号列表初始化数组元素或聚合类的成员
    -   某些类类型分配对象也会使用拷贝初始化（vector的insert\push）

******对于`explicit`的构造函数，不支持隐式转换。

******编译器可以绕过拷贝/移动构造函数，直接创建对象，但要求拷贝/移动构造函数必须存在且可访问



## **拷贝赋值运算符**

可重载，参数为运算符的运算对象。对于像赋值运算符一样的运算符的重载，必须定义为**成员函数**（运算符为成员函数，其左侧运算对象绑定到隐式的this参数）。右侧运算对象作为显示参数传递。

通常返回左侧运算对象的**引用**。

合成拷贝赋值运算符，与合成拷贝构造函数类似。



##**析构函数**

无返回类型，名字为`~T();`，不接受参数，因此不能被重载。一个给定的类，只有一个析构函数。

**完成的工作**：

|      |       先        |      后       |
| ---- | :------------: | :----------: |
| 构造函数 | 初始化成员（按类中出现顺序） |    函数体执行     |
| 析构函数 |     函数体执行      | 销毁成员（按初始化逆序） |

**什么时候调用**：

-   离开作用域
-   当一个对象被销毁，其成员也被销毁
-   容器被销毁，元素也被销毁
-   动态内存分配的对象，指向它的指针应用delete运算符时被销毁
-   临时对象，表达式结束时销毁

******析构函数本身并不直接销毁成员，成员在函数体之后隐含的析构阶段被销毁。

## 几个原则

1.  需要析构的类也需要拷贝和赋值操作
2.  需要拷贝操作的类也需要赋值操作，反之亦然

## 阻止拷贝

**定义删除的函数**

使用`=delete`指定函数为删除的。应在声明时指定，可对任意函数指定，但不能删除析、构函数。

**\*\*规则**：如果一个类有数据成员不能默认构造、拷贝、赋值或销毁；则对应的成员函数将被定义为删除的。当不可能拷贝、赋值或销毁的类的成员时，合成拷贝成员就被定义为删除的。

**private拷贝控制**

用户代码将不能拷贝这个类型的对象【编译阶段出错】，但友元函数、成员函数仍可以拷贝。

可以通过不定义的方法，阻止友元和成员函数进行拷贝【链接错误】。

使用`=delete`更好。



# 拷贝控制与资源管理

需要确定**拷贝语义**，到底是希望类表现得像一个值，还是一个指针。【这与类内部如何存储数据没有关系，是提供给类使用者的一个类表现决定的】

-   行为像**值**的类
    -   有自己的状态，拷贝时副本与原对象完全独立。如`string`
    -   定义一个拷贝构造函数，完成数据拷贝而非拷贝指针
    -   定义析构函数来释放数据
    -   定义拷贝赋值运算符来释放当前对象的数据，并从右侧对象拷贝数据【注意先后顺序】
-   行为像**指针**的类
    -   共享状态，使用相同底层数据，改变副本也会改变原对象。如`shared_ptr`
    -   使用**引用计数**（保存在动态内存中以便多个副本共享）
        -   除初始化对象外，每个构造函数（拷贝构造除外）需要创建引用计数，以记录有多少个对象在共享状态。创建对象时，设为1.
        -   拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。并递增共享计数器。
        -   析构函数递减计数器，并判断是否为0，为0则释放共享状态。
        -   拷贝赋值运算符，先递增右侧对象计数器，递减左侧对象计数器，并判断左侧对象计数器值，若变为0则销毁状态。【注意先后顺序】
-   两者皆非
    -   如`iostream`,`unique_ptr` 不允许拷贝和赋值



**拷贝赋值运算符**

1.  必须考虑**自赋值**的情况。应当保证赋值运算符是**异常安全**的，异常发生时左侧对象置于一个有意义的状态。
2.  大多数赋值运算符，组合了析构函数和拷贝构造函数的功能。

******行为像**值**的类，先拷贝数据到局部临时对象，再销毁现有成员，将临时对象拷贝到左侧运算对象的成员中。

******行为像**指针**的类，先递增**`rhs`**的计数，然后递减左侧运算对象的计数并判断，最后将右侧运算对象的值拷贝到本对象（指针等）。

# swap操作

管理资源的类通常会定义一个swap函数，若没定义则使用标准库的定义

举例而言，若对于指针类型，并不希望重新定义临时变量，并拷贝、赋值数据（1次拷贝，2次赋值），而希望直接交换指针。

```C++
class HasPtr{
  friend void swap(HasPtr &lhs, HasPtr &rhs);
  //..
  std::string *ps;
  int i;
};

inline 
void swap(HasPtr &lhs, HasPtr &rhs){
	using std::swap;
  	swap(lhs.ps, rhs.ps);
  	swap(lhs.i, rhs.i);
}
```

**应调用swap而非std::swap**

对于swap的调用应该是未加限定的。若数据成员有自定义的swap，则会比std::swap优先；若没有，则调用std的版本。

问题：为什么using没有隐藏原来类版本的swap声明？

>   对一个调用，若非函数模板和函数模板提供同样好的匹配，则选择非模板版本

**可以使用swap实现operator=**

```c++
HasPtr & HsaPtr::operator=(HasPtr rhs){
  swap(*this, rhs);
  return *this;
}
```

注意参数不是引用类型，因此是实参的一个副本，直接进行交换。函数结束时，被交换到临时变量的数据成员也会被释放。

可以处理了自赋值的情况，且是异常安全的。



# 对象移动

为了避免多余的拷贝开销，如vector的扩容等，使用移动构造函数和`std::move`

有一些标准库类，如string，都定义了移动构造函数。通常将资源“移动”而非拷贝到正在创建的对象，且保证“移后源（moved-from）”的对象仍然保持一个有效、可析构的状态（但不能保证其值）。

使用`std::move()`表明需要移动构造函数，如果不使用`move`调用，则调用拷贝构造函数。此外，使用`std::move`而非`move`。

**\*\***包含不能被共享资源的类，如`unique_ptr`或IO类，不能被拷贝但可以被移动。

**\*\***新的C++标准中，可以用容器保存不可拷贝的类型，只要能被移动即可。

## 右值引用

只能绑定到右值的引用，使用`&&`来表示。

由于是右值，因此只能绑定到**将要被销毁的对象**。所以可以自由地将一个右值引用的资源“移动”到另一个对象中。

>   左值、右值是表达式的属性。	

```c++
int i = 42;					
int &r = i;					//正确，r引用i
int &&rr = i;				//错误，rr是右值引用，i是左值表达式
int &r2 = i * 42;			//错误，r2是左值引用，i*42是右值表达式
const int &r3 = i * 42;		//正确，可以将const引用绑定到右值上
int &&rr2 = i * 42;			//正确
```

**左值持久；右值短暂**：左值有持久的状态，而右值要么是字面值，要么是求值过程中创建的临时对象

若右值引用绑定到临时对象，则可知：

-   所引用对象即将销毁
-   该对象没有其他用户

**标准库move函数**：可以显示将左值转换为对应的右值引用类型。

```
int &&rr1 = 42;
int &&rr2 = rr1;			//错误，表达式rr1是左值
int &&rr3 = std::move(rr1);	//正确
```

move的含义：有一个左值，并且希望像右值一样处理它，且隐含承诺除了对`rr1`赋值、销毁外，不再使用它。因此不对移后源对象的值有任何假设。

>   应使用`std::move`而非`move`

## 移动构造函数/移动赋值运算符

参数为**右值引用**，且要保证移后源对象处于销毁无害的状态。

```c++
StrVec::StrVec(StrVec &&s) noexpect //不应抛出异常
: elements(s.elements), first_free(s.first_free), cap(s.cap)
{
	//保证s运行析构是安全的
	s.elements = s.first_free = s.cap = nullptr;
}
```

在上述过程中，没有新的内存分配，“窃取”资源。

不抛出异常的移动构造函数，必须标记为noexpect【声明和定义中都需要标记】。

`vector`等类，在使用移动构造函数时，必须保证它是不会抛出异常的。否则当移动构造进行时发生异常，则原对象的部分已改变了，而新对象还没构造完成，不能满足抛出异常时自身不变的条件。

**移动赋值运算符**

```c++
StrVec &StrVec::operator=(StrVec &&rhs) noexpect{
  if( this != &rhs){
    free();//释放已有元素
    elements = rhs.elements;
    first_free = rhs.firstfree;
    cap = rhs.cap;
    rhs.elements = rhs.first_free = rhs.cap = nullptr;
  }
  return *this;
}
```

**移动右值，拷贝左值**

如果一个类既有移动构造函数，也有拷贝构造函数，则使用普通函数匹配规则确定调用哪个。

```c++
StrVec v1,v2;
v1 = v2;		//v2是右值，使用拷贝赋值
StrVec getVec(istream &); 	//getVec返回右值
v2= getVec(cin);			//返回右值，因此调用移动赋值运算符
```

第一个赋值，右侧表达式是**左值**因此不能调用移动赋值运算符。

第二个赋值，右侧表达式是**右值**，因此两个运算符都是可以的，但拷贝赋值运算符类型是`const StrVev&`需要转换为const，而`StrVec&&`是精确匹配，因此采用移动赋值。

******若没有移动构造函数，右值也会被拷贝。如果一个类没有移动构造函数，那么传进去的右值会作为拷贝构造函数的参数【右值类型`StrVec &&`可以转换为 `const StrVec&`】

**移动迭代器**

解引用得到右值引用，而非左值

```c++
make_move_iterator(begin());
```

接受一个普通迭代器参数，返回一个移动迭代器

**右值和左值引用的成员函数**

旧标准中，没办法阻止赋值给右值

```c++
s1 + s2 = "wow";  //s1和s2都是string
```

而使用**引用限定符**，可以指定this的左值/右值属性，只能用于非static成员函数，需要在定义和声明处都出现。

`&` 和`&&`分别表示this可以指向一个左值或是右值

```c++
class Foo{
public:
	Foo &operator=(const Foo&) &; //只能向可修改的左值赋值
  
  	Foo sorted() &&;		//用于可改变的右值
  	Foo sorted() const &;	//用于任何类型的foo
  
}
```

与const限定符一起出现时，放在const后；

引用限定属性，也可以达到**重载**函数的目的。

******如果一个成员函数有引用限定符，那么同名同参数列表的所有版本都必须有引用限定符。