# 拷贝控制

显式/隐式地指定对象拷贝、移动、赋值和销毁

# 拷贝/赋值/销毁

| 拷贝控制操作 copy control:                  | **场景类型** |      |
| :------------------------------------ | :------: | ---- |
| **拷贝构造函数**（copy constructor）          |   初始化    |      |
| **拷贝赋值运算符**（copy-assignment operator） |    赋值    |      |
| **移动构造函数**（move constructor）          |   初始化    |      |
| **移动赋值运算符**（move-assignment operator） |    赋值    |      |
| **析构函数**（destructor）                  |   销毁对象   |      |

## 拷贝构造函数

第一个参数必须是引用类型，虽然也可以接受非const引用的拷贝构造函数，但一般都是const。

合成拷贝构造函数（synthesized copy constructor），是编译器定义的构造函数。将非static成员拷贝到正在创建的对象中。对于数组类型，会逐个元素地拷贝（虽然数组无法赋值）。

**拷贝与初始化**

回顾一下直接初始化与拷贝初始化。

```c++
string dots(10,'.');			//直接初始化
string s(dots);					//直接初始化

string s2 = dots;				//拷贝初始化
string null_book = "9_999_9";	//拷贝初始化
string nines = string(100,'9');	//拷贝初始化
```

-   使用**直接初始化**时，要求编译器使用普通的函数匹配，来选择参数最匹配的构造函数。
-   使用**拷贝初始化**时，要求将右侧对象拷贝到正在创建的对象（可能隐含类型转换）。拷贝初始化，通常使用**拷贝构造函数**，也可能使用**移动构造函数**。
    -   使用`=`定义变量
    -   将对象作为实参传递给一个非引用类型的形参。【因此拷贝构造参数必须为引用，否则无限调用自己】
    -   从一个返回类型为非引用类型的函数返回一个对象
    -   花括号列表初始化数组元素或聚合类的成员
    -   某些类类型分配对象也会使用拷贝初始化（vector的insert\push）

******对于`explicit`的构造函数，不支持隐式转换。

******编译器可以绕过拷贝/移动构造函数，直接创建对象，但要求拷贝/移动构造函数必须存在且可访问



## **拷贝赋值运算符**

可重载，参数为运算符的运算对象。对于像赋值运算符一样的运算符的重载，必须定义为**成员函数**（运算符为成员函数，其左侧运算对象绑定到隐式的this参数）。右侧运算对象作为显示参数传递。

通常返回左侧运算对象的**引用**。

合成拷贝赋值运算符，与合成拷贝构造函数类似。



##**析构函数**

无返回类型，名字为`~T();`，不接受参数，因此不能被重载。一个给定的类，只有一个析构函数。

**完成的工作**：

|      |       先        |      后       |
| ---- | :------------: | :----------: |
| 构造函数 | 初始化成员（按类中出现顺序） |    函数体执行     |
| 析构函数 |     函数体执行      | 销毁成员（按初始化逆序） |

**什么时候调用**：

-   离开作用域
-   当一个对象被销毁，其成员也被销毁
-   容器被销毁，元素也被销毁
-   动态内存分配的对象，指向它的指针应用delete运算符时被销毁
-   临时对象，表达式结束时销毁

******析构函数本身并不直接销毁成员，成员在函数体之后隐含的析构阶段被销毁。

## 几个原则

1.  需要析构的类也需要拷贝和赋值操作
2.  需要拷贝操作的类也需要赋值操作，反之亦然

## 阻止拷贝

**定义删除的函数**

使用`=delete`指定函数为删除的。应在声明时指定，可对任意函数指定，但不能删除析、构函数。

**\*\*规则**：如果一个类有数据成员不能默认构造、拷贝、赋值或销毁；则对应的成员函数将被定义为删除的。当不可能拷贝、赋值或销毁的类的成员时，合成拷贝成员就被定义为删除的。

**private拷贝控制**

用户代码将不能拷贝这个类型的对象【编译阶段出错】，但友元函数、成员函数仍可以拷贝。

可以通过不定义的方法，阻止友元和成员函数进行拷贝【链接错误】。

使用`=delete`更好。



# 拷贝控制与资源管理

需要确定**拷贝语义**，到底是希望类表现得像一个值，还是一个指针。【这与类内部如何存储数据没有关系，是提供给类使用者的一个类表现决定的】

-   行为像**值**的类
    -   有自己的状态，拷贝时副本与原对象完全独立。如`string`
    -   定义一个拷贝构造函数，完成数据拷贝而非拷贝指针
    -   定义析构函数来释放数据
    -   定义拷贝赋值运算符来释放当前对象的数据，并从右侧对象拷贝数据【注意先后顺序】
-   行为像**指针**的类
    -   共享状态，使用相同底层数据，改变副本也会改变原对象。如`shared_ptr`
    -   使用**引用计数**（保存在动态内存中以便多个副本共享）
        -   除初始化对象外，每个构造函数（拷贝构造除外）需要创建引用计数，以记录有多少个对象在共享状态。创建对象时，设为1.
        -   拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。并递增共享计数器。
        -   析构函数递减计数器，并判断是否为0，为0则释放共享状态。
        -   拷贝赋值运算符，先递增右侧对象计数器，递减左侧对象计数器，并判断左侧对象计数器值，若变为0则销毁状态。【注意先后顺序】
-   两者皆非
    -   如`iostream`,`unique_ptr` 不允许拷贝和赋值



**拷贝赋值运算符**

1.  必须考虑**自赋值**的情况。应当保证赋值运算符是**异常安全**的，异常发生时左侧对象置于一个有意义的状态。
2.  大多数赋值运算符，组合了析构函数和拷贝构造函数的功能。

******行为像**值**的类，先拷贝数据到局部临时对象，再销毁现有成员，将临时对象拷贝到左侧运算对象的成员中。

******行为像**指针**的类，先递增**`rhs`**的计数，然后递减左侧运算对象的计数并判断，最后将右侧运算对象的值拷贝到本对象（指针等）。



