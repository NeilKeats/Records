# Hash

使用Hash（散列）表存储数据，大小为$$TableSize$$，从$$0$$到$$TableSize-1$$变化。

通过哈希函数，直接映射到对应存储位置，实现$$O(1)$$的插入、查询、删除。空间代价O$$(N)$$



#Hash函数

定义**Hash函数**：关键字映射到$$TableSize$$范围内某个数

**\*\***一般合理方法："$$Key$$ mod $$TableSize$$"

**\*\***容易出现对部分输入不良的散列，$$TableSize$$是素数较好

## 关键字为字符串

### 所有ASCII码之和作为$key$

```c++
unsigned int
Hash1( const char *key, int TableSize){
    unsigned int HashVal = 0;
    while(*key != '\0')
		HashVal += *key++;
    
	return HashVal % TableSize;
}
```

**缺点：**

输入受限：假设关键字长为8个字符，取值范围为$$0$$~$$127*8=1016$$，对于大的$$TableSize$$无法均匀分配。

### 前三个字符的加权和

```c++
unsigned int
Hash2( const char *key, int TableSize){
	//这里简化，27包括 26个英文和1个空格； 729 = 27 * 27
	unsigned int HashVal = key[0] + 27 * key[1] + 729*key[2];
	
	return HashVal % TableSize;
}
```

**缺点：**

英文的前三个字符并非随机分布

取值范围：$$0$$~$$26^3=17576$$，仍然不够大。

### Horner多项式法则

既然使用3个字符的效果不好，那可以考虑用全部字符的‘’加权和‘’

法则：
$$
HashVal=\sum_{i=0}^{KeySize-1}Key[KeySize-i-1]·32^i
$$

```c++
unsigned int
Hash3( const char *key, int TableSize){

	unsigned int HashVal = 0;
	while(*key != '\0')
		HashVal = (HashVal<<5) + *key++;
    
	return HashVal % TableSize;
}
```

**优化：**

使用32作为多项式的基数，可以通过左移操作快速计算。此外，加法也可以通过异或操作代替。

**缺点：**

关键字过长时

1.  时间复杂度高
2.  前面的字符会被移除出最终结果

可行的解决方法：不使用全部字符，只使用奇/偶数

# Hash冲突如何解决？

定义装填因子$$λ$$：Hash表中**元素个数**与Hash**表大小**的比值。

## 分离链接法（seperate chaining）

**KeyIdea:**

将Hash到**同一个值**的所有元素，保留到**一个表**中。（链表，二叉查找树，另一个散列表）

分离链接法的一般法则是，表大小与元素数目差不多（$$λ≈1$$）。

**缺点：**

需要指针；分配空间给新单元需要时间

## 开放定址法（open addressing hashing）

**KeyIdea:**

当冲突发生时，尝试选择其他单元，直到找到为止。

如相继试选$$h_0(X),h_1(X),h_2(X) ...$$，其中$$h_i(X)=(Hash(X) + F(i))\ mod\ TableSize$$，且$$F(0)=0$$，$$F$$函数为冲突解决方法

一般来说，开放定址法的装填因子应该低于$$λ=0.5$$

此外，不存在常规删除操作，因为会影响其他单元（查找过程）。因此采取惰性删除。

### 线性探测法

线性地探测下一个单元，$$F(i)=i$$

**存在问题**：

**一次聚集**，冲突的单元形成区块。插入和不成功的查找，需要相同次探测。在装填因子增加时，探测次数显著增加。

### 平方探测法

解决一次聚集问题，$$F(i)=i^2$$

**存在问题：**

一旦表被填充超过一半，当表大小不是素数时甚至在表被填满一半之前，就无法保证能找到一个空单元。【因为最多有表的一半用作解决冲突的备选位置】

必须确保表填充的元素数目小于一半，且素数也是重要的。

**缺点：**

存在**二次聚集**

### 双散列

$$F(i)=i·hash_2(X)$$

对$$Hash_2$$的选择要求较高，且不能为0（否则探测永远失败）；还应尽量保证所有单元都被探测到

# 再Hash（rehashing）

另一种方法是，重新建立哈希表。

创建一个约为原表大小**两倍**的哈希表，且使用一个新的哈希函数，扫描原始散列表。

时间复杂度为$$O(N)$$，由于之前已经存在$$N/2$$次插入，因此均摊下来为常数开销

时机的策略选择有：

-   表满一半
-   插入失败才执行
-   达到某个装填因子



# 可扩散列

考虑内存太小，无法放下全部数据的情况。瓶颈变为：存取磁盘次数







