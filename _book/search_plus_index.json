{"./":{"url":"./","title":"ReadMe","keywords":"","body":"笔记 & "},"biao-da-shi.html":{"url":"biao-da-shi.html","title":"表达式 expression","keywords":"","body":"概念： 表达式 expression， 对表达式求值得到一个结果，字面值和变量是最简单的表达式。把一个运算符与一个或多个运算对象组合起来可以得到复杂表达式 运算对象 operand 运算符 opeartor：一元unary、二元binary 组合运算符与运算对象，多个运算符的表达式，需要考虑优先级、结合律、求值顺序 运算对象转换，将运算对象从一个类型转为另一个类型 重载运算符，无法改变优先级、结合律、运算对象个数 左值与右值 左值表达式：求值结果是一个对象或者函数。 对象用于右值时，用的是对象的值（内容），用做左值时，用的是对象的身份（在内存中位置）。 左值可代替右值使用，反之不行 优先级，结合律，求值顺序 优先级：哪个运算符先组合（eg. *优先级比+高） 结合律：左结合律，则相同运算符从左到右开始顺序组合（eg. std::cout>>i1>>i2>>endl; >>是左结合律） 括号无视组合规则 求值顺序：大多数情况不明确表达式中运算对象的求值顺序。 4个运算符规定求值顺序：逻辑与（&&）、逻辑或（||）、逗号（,）、条件运算符（?:） Int i = f1()*f2(); //不确定发f1与f2的调用顺序； std::cout 例 f()+g()*h()+j(); 优先级：g()返回值先与h()返回值相乘 结合律：f()返回值先于g()*h()返回相加，结果再与j()返回值相加 求值顺序：这些函数调用顺序无明确规定 运算符 算数运算符 除非特殊说明，能用于任意算数类型；运算对象、求值结果都是右值。 取模、取余运算：C++规定商向0取（切除小数部分）。要求：(m/n)*n + m%n == m，即m%n若不为0则与m同号 逻辑和关系运算符 与、或：左侧为真时才计算右侧对象（短路求值 short-circuit evaluation） 关系运算符（>,>=,） 进行比较运算时除非比较对象是bool，否则不使用bool字面值true和false 赋值预算符 左侧运算对象必须是可修改的左值，结果也是左侧运行对象的左值。满足右结合律 C++11允许花括号初始化 vector vi={1,2,3,4,5}; 递增、递减运算符 前置版本：以左值形式返回对象本身 后置版本：以右值形式返回对象原始值副本（非必要时不用，由于副本存在可能影响性能） 成员访问运算符 指针类型ptr，ptr->mem等价于(*ptr).mem 箭头运算符->，结果是左值 点运算符.，若成员是左值则结果为左值，反之为右值 条件运算符?: 可嵌套，右结合律，从右到左组合。 优先级低，长表达式中嵌套了条件运算符子表达式，通常需要加括号 位运算符 ~ 位求反 左移 >> 右移 & 位与 \\ 位或 ^ 位异或 左移/右移，右侧运算对象不能为负值且不可超过结果位数，移出界外的值舍弃 移位运算符 cout 左结合律，返回左值。运算优先级比关系、赋值、条件运算符的优先级高。 sizeof运算符 右结合律，返回size_t类型的常量表达式 并不实际计算运算对象的值，因此对无效指针p运算的size(*p)是安全的 逗号运算符 含有两个运算对象，按从左到右求值。先求左侧表达式的值，并抛弃求值结果，真正结果是右侧表达式的值（若右侧表达式运算对象是左值，则求值结果也算左值） 类型转换 算术转换 整型提升：小整数类型转换为大整数类型，保证提升为能容纳原类型所有可能的值的大类型 无符号类型的运算对象：运算对象的类型不一致，需转为同一种类型。先整型提升，若匹配无需进一步转换。若一个为有符号、另一个为无符号，只有无符号的对象的所有可能值可以被有符号类型容纳，才将无符号对象转换为有符号类型（其他情况将有符号对象转为无符号类型）。 例： short sval; char cval; int ival; long lval; unsigned short usval; unsigned int uival; sval + cval; //sval和cval提升为int usval + ival; //根据unsigned short 和 int所占空间大小进行提升 uival + lval; //根据unsigned int 和 long所占空间的大小进行转换 其他类型隐式转换 数组转换为指针。当数组用作decltype、sizeof、&取址符、typeid时，不发生以下转换。 int ia[10]; int *ip = ia; 整数0、字面常量值nullptr能转换为任意指针类型；指向任意非常量的指针能转换为void*；指向任意对象的指针能转换成const void*。 显式转换 强制类型转换 cast-name(expression); //cast-name为 static_cast、dynamic_cast、const_cast和 reinterpret_cast Dynamic_cast：支持运行时类型识别 Static_cast：任何具有明确意义的类型转换，只要不包含底层const都可用。可用于较大算数类型转换为较小类型、void*转换为其他类型指针 Const_cast：只能改变运算对象的底层const const char *pc; char *p = const_cast(pc); //正确，但通过p写值是未定义行为 "},"yu-ju-statement-and-hanshu-function.html":{"url":"yu-ju-statement-and-hanshu-function.html","title":"语句 statement & 函数 function","keywords":"","body":"1. 语句 空语句 ;//空语句 1.2 复合语句 花括号括起来的语句和声明序列，也成为块 1.3 范围for 不能通过范围for向vector等对象增加元素，因为预存了end的值，可能失效。 for (auto &r : v) r *= 2; //等价于 for(auto beg = v.begin(), end=v.end(); beg!= end; ++beg){ auto &r = *begin; r *= 2; } 1.4 try语句 try{ program-statements } catch (exception-declaration){ handler-statements } catch (exception-declaration){ handler-statements } //.. 2. 函数 形参（parameter） 实参（argument）：形参的初始值，实参求值顺序不规定。 调用运算符（call operator）: () 函数调用完成两项工作 用实参初始化形参（隐式定义并初始化 将控制权转交给被调用函数（主函数此时被暂时中断）。 return语句结束函数执行过程，完成两个工作： 返回return语句中的值（若有） 将控制权从被调函数转回主调函数。不能返回数组、函数，但可以返回指向数组或者函数的指针 2.1 局部对象与生命周期 名字有作用域（在其中可见） 生命周期是该对象存在的一段时间 局部对象：形参、函数体内部定义的变量，为局部对象（local variable） 自动对象：函数控制路径经过变量定义语句时创建，块尾部销毁。只存在于块控制期间的对象为自动对象。形参为实参初始化的自动对象，对于自动对象若无初始值则默认初始化。 局部静态对象（Local static object）：生命周期贯穿函数调用及之后的时间。在执行路径第一次经过对象定义语句时初始化，程序结束时销毁。 2.2 分离式编译 修改了其中一个源文件，只需要重新编译那个改动了的文件。产生后缀为.obj(Win)或.o(UNIX)的文件，含义为该文件包含对象代码(object code)。 编译器将对象文件链接成可执行文件 2.3 内联函数 在每个调用点上“内联地”展开，避免调用开销。 #向编译器发出请求，编译器可以拒绝 2.4 constexpr函数 能作用于常量表达式的函数 约束： 返回类型和所有形参的类型都得是字面值类型； 有且只有一条return语句 #编译器把对constexpr函数的调用替换成结果值，为了能在编译过程中展开，constexpr函数被隐式地指定为内联函数 允许constexpr函数返回值并非常量。（例，写为，用非常量表达式调用返回非常量表达式，用常量表达式调用返回常量表达式） 内联函数和constexpr函数可以多次定义，必须完全一致（展开函数需要其定义）。通常定义在头文件中。 3. 函数参数传递 实参对形参初始化。 形参为引用类型，则绑定到对应实参（引用传递）；否则值拷贝后赋值给形参（值传递）。 3.1 const形参和实参 实参初始化形参时忽略顶层const。形参为const时，传给它常量或非常量都可以。 void fcn(const int i) {} void fcn(int i){} //错误，重复定义func(int) 虽然函数可以重载，但是形参列表应该有区别。上述两个函数参数可以完全一样，因此第二个定义有错。（guess：顶层const无法重载.？） 3.2 指针或引用形参与const 可以用非常量初始化底层const，反之不行。 只有引用传递和指针传递可以用是否加const来重载。 3.3 尽量使用常量引用 传入参数限制：无法传入const对象。 适应性：其他函数正确定义const引用，但非常量引用的函数无法在其中调用 3.4 数组形参 数组特点：不允许拷贝数组、使用时通常转换为指针 无法值传递，传递时数组会被转换为指针，数组大小无影响。 形参可写为： void print(const int*); void print(const int[]); void print(const int[10]); //表示期望数组的元素数目，但实不一定如此 上述三个函数等价，形参都为 const int*，传入时只检查参数是否为const int *。 3.4.1 指定数组大小 用标记指定数组结束，如字符数组的'\\0'，读到表示数组结束 使用标准库规范：传入数组首元素、尾后元素的指针 显式传递数组大小： 3.4.2 数组引用形参和const 变量（形参）可定义为数组的引用 //正确：形参是数组的引用，维度是类型的一部分 void print(int (&arr)[10]){ for (auto elem : arr) cout 数组大小是构成数组类型的一部分，不超过维度都可在函数体内使用。 当不需要对数组元素执行写操作时，形参应该为指向const的指针。 3.4.3 多维数组 C++没有真正意义的多维数组，是数组的数组。 传递多维数组时，传递的是指向数组首元素的指针。 //matrix指向数组的首元素，该数组的元素是由10个整数构成的数组。matrix括号不可忽略！ void print(int (*matrix)[10], int rowSize){}; 也可以使用数组语法定义，第一个维度会被忽略因此不适宜放在形参列表中 //等价定义 void print(int matrix[][10], int rowSize){}; 3.5 可变形参的函数 使用initializer_list标准库类型 特殊形参类型：省略符。一般只用于与C函数交互的接口 3.6 默认实参 可以为形参提供默认实参，作为初始值出现在形参列表中。 一旦某个形参被赋予默认值，它后面所有形参必须有默认值。 默认实参声明 一个函数可以声明多次，但给定作用域中，一个形参只能被赋予一次默认实参。 同一个函数的后续声明，只能为之前没有被赋予默认值的形参添加默认实参，且形参右侧的所有形参必须有默认值。 局部变量不能作为默认实参（即，全局变量可以）。表达式的类型能转换为形参所需类型也可以。 默认实参名字在函数声明所在的作用域内解析，求值过程发生在函数调用时。（即，默认实参为某个全局变量，调用时求全局变量值（可能会在运行时发生改变）） 4. 返回类型与return语句 返回值的方式和初始化形参、变量的方式一样：返回值用于初始化调用点的一个临时量，临时量就是函数调用的结果。 返回引用，引用为所引对象的别名。因此，不返回局部对象的引用或指针。若返回引用得到左值，其他返回类型得到右值。 const string &manip(){ //局部变量 string ret; //某些处理ret if(!ret.empty()) return ret; //错误：返回局部对象引用 else return \"Empty\"; //错误：\"Empty\"是一个局部临时量 ｝ 列表初始化返回，用花括号初始化。 vector process(){ // ... return {\"functionX\",\"Okay}; } 返回数组指针 数组特点：不可拷贝，因此可以返回数组指针或引用。 声明一个返回数组指针的函数： int arr[10]; int *p1[10]; //含有10个指针的数组 int (*p2)[10] = &arr; //指向含有10个整型的数组的指针 若要返回一个数组指针，数组维度必须跟在函数名字之后。形参也跟在函数名前且先于数组维度。 Type (*function(parameter list)) [dimension]; int (*func(int i))[10]; //使用类型别名代替 typedef int arrT[10]; using arrT = int[10]; arrT* func(int i); 使用尾置返回类型（C++11）【也可使用decltype】 auto func(int i) -> int(*)[10] 主函数main 可以没有return语句，编译器隐式插入返回0的return语句。 不可调用自己 递归：直接、间接调用自己 5. 函数重载 同一个 作用域内，几个函数名字相同但形参不同，称之为重载函数 #main函数不能重载 #不允许两个函数除了返回类型外，其他要素相同 5.1 重载与const形参 如上所述，顶层const不影响传入函数的对象。一个有顶层const的形参无法与另一个无顶层const的形参区分。 int func(int); int func(const int); //重复声明 int func_(int*); int func_(int* const); //顶层const,重复声明 底层const可以实现重载 int func(int &); int func(const int &); //合法重载，常量引用 int func_(int*); int func_(const int*); 底层const只能传给const。由于非常量可以转换为const，非常量引用、指向非常量的指针可以作用于以上四个函数，在调用时，编译器将非常量的参数优先调用非常量的重载函数。 5.2 const_cast与重载 //常量引用版本 const string &shorter_string(const string &s1, const string &s2){ return s1.size()(s1), const_cast(s2)); return const_cast(r); } 5.3 调用重载的函数 函数匹配（function matching），又叫重载确定（overload resolution） 把函数调用与一组重载函数中的某一个关联起来。将调用的实参与重载集合中的每一个函数的形参进行比较，再根据比较结果决定调用哪个： 找到一个与实参最佳匹配的（best mtach）的函数，生成调用的代码。 找不到任何一个匹配，编译器发出无匹配（no match）的错误。 有多于一个的函数可以匹配，但每一个都不是明显更好的选择。发生错误，二义性调用（ambiguous call） 5.4 重载与作用域 如果在内层作用域声明名字，将隐藏外层作用域中的同名实体。不同作用域中无法重载。 #C++中，名字查找发生在类型检查之前。 6. 函数匹配 "},"er-cha-shu.html":{"url":"er-cha-shu.html","title":"二叉树","keywords":"","body":"1. 树的递归定义 树为节点集合，若节点非空，则有由一个根节点和0个或多个非空的（子）树组成，每个子树的根都被来自根r的一条有向边所连接。 树叶、兄弟、父亲、祖先、后裔 路径：从节点n1到nk的path定义为节点n1,n2,n3,…,nk的一个序列：使得1 深度：根到ni的唯一路径的长，（根的深度为0） 高度：ni到一片树叶的最长路径的长。所有树叶高度为0，一棵树的高等于根的高 内部路径长：所有节点的深度。 2. 遍历二叉树（traversal） 2.1 BFS，队列 按层：往往要求获取层数信息（维护两个last变量，一个指向当前层，一个指向下一层） https://leetcode.com/problems/binary-tree-level-order-traversal 2.2 DFS，栈 递归的函数上下文栈，或者循环+栈。递归简单清晰，应练习非递归的循环遍历方法 先序遍历(pre-order)：node, child left, child right https://leetcode.com/problems/binary-tree-preorder-traversal/ 中序遍历(in-order)：child left, node, child right https://leetcode.com/problems/binary-tree-inorder-traversal/ 后序遍历(post-order)：child left, child right, node https://leetcode.com/problems/binary-tree-postorder-traversal/ （先序）序列化： 加入空字符#、结束字符！ 反序列化： 由输入字符串->vector \"12!3!#!#!#!\" -> [\"12\",\"3\",\"#\",\"#\",\"#\"] 3.二叉搜索树 树的任意点期望深度为O(logN)，平均操作复杂度为O(logN)。但删除操作会破坏这种平均特性，由于删除时，把右子树的最小节点代替原节点，有助于使得左子树比右子树更深。 已证明，交替插入删除Θ(N^2)次，期望深度将为Θ(sqrt(N))。 可通过交替选取右子树最小、左子树最大元素来代替被删节点来消除。 若向预先排序的树输入数据，一连串insert花费二次时间，链表实现代价很大，树由那些没有左儿子的节点组成。 解决方法：附加条件“平衡” 3.1 AVL树 带平衡条件的二叉查找树，保证树深度为O(logN) 定义：每个节点的左子树和右子树的高度最多差1的二叉查找树。（空树高度为-1） 插入可能破坏条件，通过“旋转”来修正。插入之后，只有插入点到根节点的平衡可能被改变（只有这些节点的子树可能发生改变），沿此路径上行并更新平衡信息。 3.1.1 旋转操作： 找出第一个破坏AVL条件的节点α（最深的节点），并重新平衡。 四种情况（WHY？，α的左右子树高度差4，若插在左/右儿子则高度差不可能为2，α不可能为第一个破坏点）： 对α的左儿子的左子树插入 对α的左儿子的右子树插入 对α的右儿子的左子树插入（与2.对称） 对α的右儿子的右子树插入（与1.对称） 通过单旋转、双旋转来解决。实现可递归定义插入、左/右的单/双旋转。 3.1.2 单旋转（左-左/右-右） 3.1.2 双旋转（左-右/右-左） 3.2 伸展树（Splay Tree） 放弃平衡条件，允许任意深度，但每次操作之后调整； 连续M次操作平均最坏情况O(MlogN)，无法保证任意一次操作花费O(N)的可能。 对于二叉查找树最坏情况O(N)，若要求最差情况O(MlogN)则节点被访问之后必须被移动，否则一直访问最坏节点则有O(MN) 基本想法：当一个节点被访问后，经过一系列AVL树的旋转被构造到根节点。若该点很深，则路径上的许多存在节点也相对比较深，重新构造可以使得对这些节点的访问时间变少。（实际上，一个节点被访问之后，可能不久再次被访问） 不保留高度或平衡信息 3.2.1 平衡方法 直接单旋转，对最坏情况复杂度为O(MN)，因此不可行。 展开操作：X为目标节点，若其父为根节点，直接单旋转。否则分为以下情况 3.2.2 之字形（Zig-zag），即采用AVL的双旋转 3.2.3 一字型（Zig-zig） "}}