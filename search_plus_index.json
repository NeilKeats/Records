{"./":{"url":"./","title":"Introduction","keywords":"","body":" 为保证阅读效果，建议转跳到Gitbook或GithubIO Introduction 使用gitbook构建的计算机笔记，内容包括： C++/JAVA， 数据结构， 计算机网络， 安卓 作者： [炎之凯](https://github.com/totond) [Neilkeats](https://github.com/NeilKeats) "},"C++/biao-da-shi.html":{"url":"C++/biao-da-shi.html","title":"表达式 expression","keywords":"","body":"概念： 表达式 expression， 对表达式求值得到一个结果，字面值和变量是最简单的表达式。把一个运算符与一个或多个运算对象组合起来可以得到复杂表达式 运算对象 operand 运算符 opeartor：一元unary、二元binary 组合运算符与运算对象，多个运算符的表达式，需要考虑优先级、结合律、求值顺序 运算对象转换，将运算对象从一个类型转为另一个类型 重载运算符，无法改变优先级、结合律、运算对象个数 左值与右值 左值表达式：求值结果是一个对象或者函数。 对象用于右值时，用的是对象的值（内容），用做左值时，用的是对象的身份（在内存中位置）。 左值可代替右值使用，反之不行 优先级，结合律，求值顺序 优先级：哪个运算符先组合（eg. *优先级比+高） 结合律：左结合律，则相同运算符从左到右开始顺序组合（eg. std::cout>>i1>>i2>>endl; >>是左结合律） 括号无视组合规则 求值顺序：大多数情况不明确表达式中运算对象的求值顺序。 4个运算符规定求值顺序：逻辑与（&&）、逻辑或（||）、逗号（,）、条件运算符（?:） Int i = f1()*f2(); //不确定发f1与f2的调用顺序； std::cout 例 f()+g()*h()+j(); 优先级：g()返回值先与h()返回值相乘 结合律：f()返回值先于g()*h()返回相加，结果再与j()返回值相加 求值顺序：这些函数调用顺序无明确规定 运算符 算数运算符 除非特殊说明，能用于任意算数类型；运算对象、求值结果都是右值。 取模、取余运算，几个特点： 若商运算两个运算对象符号相同，则结果为正数 C++11规定商向0取（切除小数部分） 取余的运算对象都为整数类型 (m/n)*n + m%n == m，即m%n若不为0则与m同号 逻辑和关系运算符 与、或：左侧为真时才计算右侧对象（短路求值 short-circuit evaluation） 关系运算符（>,>=,） 进行比较运算时除非比较对象是bool，否则不使用bool字面值true和false 赋值预算符 左侧运算对象必须是可修改的左值，结果也是左侧运行对象的左值。满足右结合律 C++11允许花括号初始化 vector vi={1,2,3,4,5}; 递增、递减运算符 前置版本：以左值形式返回对象本身 后置版本：以右值形式返回对象原始值副本（非必要时不用，由于副本存在可能影响性能） 成员访问运算符 指针类型ptr，ptr->mem等价于(*ptr).mem 箭头运算符->，结果是左值 点运算符.，若成员是左值则结果为左值，反之为右值 条件运算符?: 可嵌套，右结合律，从右到左组合。 优先级低，长表达式中嵌套了条件运算符子表达式，通常需要加括号 位运算符 ~ 位求反 左移 >> 右移 & 位与 \\ 位或 ^ 位异或 左移/右移，右侧运算对象不能为负值且不可超过结果位数，移出界外的值舍弃 左移运算符右侧用0填充，对于无符号/有符号类型一样 右移运算符>>的左侧填充bit与类型有关：无符号类型填充0，有符号类型根据实现不同或填充0或填充符号位（微软的实现中填充符号位） https://docs.microsoft.com/en-us/cpp/cpp/left-shift-and-right-shift-operators-input-and-output?view=vs-2017 移位运算符（IO运算符） cout 重载版本常用于IO操作，结合律优先级与原来一样。 左结合律，返回左值。运算优先级比关系、赋值、条件运算符的优先级高。 sizeof运算符 右结合律，返回size_t类型的常量表达式 并不实际计算运算对象的值，因此对无效指针p运算的size(*p)是安全的 逗号运算符 含有两个运算对象，按从左到右求值。先求左侧表达式的值，并抛弃求值结果，真正结果是右侧表达式的值（若右侧表达式运算对象是左值，则求值结果也算左值） 类型转换 算术转换 整型提升：小整数类型转换为大整数类型，保证提升为能容纳原类型所有可能的值的大类型 无符号类型的运算对象：运算对象的类型不一致，需转为同一种类型。先整型提升，若匹配无需进一步转换。若一个为有符号、另一个为无符号，只有无符号的对象的所有可能值可以被有符号类型容纳，才将无符号对象转换为有符号类型（其他情况将有符号对象转为无符号类型）。 例： short sval; char cval; int ival; long lval; unsigned short usval; unsigned int uival; sval + cval; //sval和cval提升为int usval + ival; //根据unsigned short 和 int所占空间大小进行提升 uival + lval; //根据unsigned int 和 long所占空间的大小进行转换 其他类型隐式转换 数组转换为指针。当数组用作decltype、sizeof、&取址符、typeid时，不发生以下转换。 int ia[10]; int *ip = ia; 整数0、字面常量值nullptr能转换为任意指针类型；指向任意非常量的指针能转换为void*；指向任意对象的指针能转换成const void*。 显式转换 强制类型转换 cast-name(expression); //cast-name为 static_cast、dynamic_cast、const_cast和 reinterpret_cast Dynamic_cast：支持运行时类型识别 Static_cast：任何具有明确意义的类型转换，只要不包含底层const都可用。可用于较大算数类型转换为较小类型、void*转换为其他类型指针 Const_cast：只能改变运算对象的底层const const char *pc; char *p = const_cast(pc); //正确，但通过p写值是未定义行为 "},"C++/yu-ju-statement-and-hanshu-function.html":{"url":"C++/yu-ju-statement-and-hanshu-function.html","title":"语句 statement & 函数 function","keywords":"","body":"语句 空语句 ;//空语句 复合语句 花括号括起来的语句和声明序列，也称为块 范围for 不能通过范围for向vector等对象增加元素，因为预存了end的值，可能失效。 for (auto &r : v) r *= 2; //等价于 for(auto beg = v.begin(), end=v.end(); beg!= end; ++beg){ auto &r = *begin; r *= 2; } try语句 try{ program-statements } catch (exception-declaration){ handler-statements } catch (exception-declaration){ handler-statements } //.. 函数 形参（parameter） 实参（argument）：形参的初始值，实参求值顺序不规定。 调用运算符（call operator）: () 函数调用完成两项工作 用实参初始化形参（隐式定义并初始化 将控制权转交给被调用函数（主函数此时被暂时中断）。 return语句结束函数执行过程，完成两个工作： 返回return语句中的值（若有） 将控制权从被调函数转回主调函数。不能返回数组、函数，但可以返回指向数组或者函数的指针 局部对象与生命周期 名字有作用域（在其中可见） 生命周期是该对象存在的一段时间 局部对象：形参、函数体内部定义的变量，为局部对象（local variable） 自动对象：函数控制路径经过变量定义语句时创建，块尾部销毁。只存在于块控制期间的对象为自动对象。形参为实参初始化的自动对象，对于自动对象若无初始值则默认初始化。 局部静态对象（Local static object）：生命周期贯穿函数调用及之后的时间。在执行路径第一次经过对象定义语句时初始化，程序结束时销毁。 分离式编译 修改了其中一个源文件，只需要重新编译那个改动了的文件。产生后缀为.obj(Win)或.o(UNIX)的文件，含义为该文件包含对象代码(object code)。 编译器将对象文件链接成可执行文件 内联函数 在每个调用点上“内联地”展开，避免调用开销。 #向编译器发出请求，编译器可以拒绝 constexpr函数 能作用于常量表达式的函数 约束： 返回类型和所有形参的类型都得是字面值类型； 有且只有一条return语句 #编译器把对constexpr函数的调用替换成结果值，为了能在编译过程中展开，constexpr函数被隐式地指定为内联函数 允许constexpr函数返回值并非常量。（例，写为，用非常量表达式调用返回非常量表达式，用常量表达式调用返回常量表达式） 内联函数和constexpr函数可以多次定义，必须完全一致（展开函数需要其定义）。通常定义在头文件中。 函数参数传递 实参对形参初始化。 形参为引用类型，则绑定到对应实参（引用传递）；否则值拷贝后赋值给形参（值传递）。 const形参和实参 实参初始化形参时忽略顶层const。形参为const时，传给它常量或非常量都可以。 void fcn(const int i) {} void fcn(int i){} //错误，重复定义func(int) 虽然函数可以重载，但是形参列表应该有区别。上述两个函数参数可以完全一样，因此第二个定义有错。（guess：顶层const无法重载.？） 指针或引用形参与const 可以用非常量初始化底层const，反之不行。 只有引用传递和指针传递可以用是否加const来重载。 尽量使用常量引用 传入参数限制：普通引用无法传入const对象。 适应性：其他函数正确定义const引用，但非常量引用的函数无法在其中调用 数组形参 数组特点：不允许拷贝数组、使用时通常转换为指针 无法值传递，传递时数组会被转换为指针，数组大小无影响。 形参可写为： void print(const int*); void print(const int[]); void print(const int[10]); //表示期望数组的元素数目，但实不一定如此 上述三个函数等价，形参都为 const int*，传入时只检查参数是否为const int *。 指定数组大小 用标记指定数组结束，如字符数组的'\\0'，读到表示数组结束 使用标准库规范：传入数组首元素、尾后元素的指针 显式传递数组大小 数组引用形参和const 变量（形参）可定义为数组的引用 //正确：形参是数组的引用，维度是类型的一部分 void print(int (&arr)[10]){ for (auto elem : arr) cout 数组大小是构成数组类型的一部分，不超过维度都可在函数体内使用。 当不需要对数组元素执行写操作时，形参应该为指向const的指针。 多维数组 C++没有真正意义的多维数组，是数组的数组。 传递多维数组时，传递的是指向数组首元素的指针。 //matrix指向数组的首元素，该数组的元素是由10个整数构成的数组。matrix括号不可忽略！ void print(int (*matrix)[10], int rowSize){}; 也可以使用数组语法定义，第一个维度会被忽略因此不适宜放在形参列表中 //等价定义 void print(int matrix[][10], int rowSize){}; 可变形参的函数 使用initializer_list标准库类型 特殊形参类型：省略符。一般只用于与C函数交互的接口 默认实参 可以为形参提供默认实参，作为初始值出现在形参列表中。 一旦某个形参被赋予默认值，它后面所有形参必须有默认值。 默认实参声明 一个函数可以声明多次，但给定作用域中，一个形参只能被赋予一次默认实参。 同一个函数的后续声明，只能为之前没有被赋予默认值的形参添加默认实参，且形参右侧的所有形参必须有默认值。 局部变量不能作为默认实参（即，全局变量可以）。表达式的类型能转换为形参所需类型也可以。 默认实参名字在函数声明所在的作用域内解析，求值过程发生在函数调用时。（即，默认实参为某个全局变量，调用时求全局变量值（可能会在运行时发生改变）） 返回类型与return语句 返回值的方式和初始化形参、变量的方式一样：返回值用于初始化调用点的一个临时量，临时量就是函数调用的结果。 返回引用，引用为所引对象的别名。因此，不返回局部对象的引用或指针。若返回引用得到左值，其他返回类型得到右值。 const string &manip(){ //局部变量 string ret; //某些处理ret if(!ret.empty()) return ret; //错误：返回局部对象引用 else return \"Empty\"; //错误：\"Empty\"是一个局部临时量 ｝ 列表初始化返回，用花括号初始化。 vector process(){ // ... return {\"functionX\",\"Okay}; } 返回数组指针 数组特点：不可拷贝，因此可以返回数组指针或引用。 声明一个返回数组指针的函数： int arr[10]; int *p1[10]; //含有10个指针的数组 int (*p2)[10] = &arr; //指向含有10个整型的数组的指针 若要返回一个数组指针，数组维度必须跟在函数名字之后。形参也跟在函数名前且先于数组维度。 Type (*function(parameter list)) [dimension]; int (*func(int i))[10]; //使用类型别名代替 typedef int arrT[10]; using arrT = int[10]; arrT* func(int i); 使用尾置返回类型（C++11）【也可使用decltype】 auto func(int i) -> int(*)[10] 主函数main 可以没有return语句，编译器隐式插入返回0的return语句。 不可调用自己 递归：直接、间接调用自己 函数重载 同一个 作用域内，几个函数名字相同但形参不同，称之为重载函数 #main函数不能重载 #不允许两个函数除了返回类型外，其他要素相同 重载与const形参 如上所述，顶层const不影响传入函数的对象。一个有顶层const的形参无法与另一个无顶层const的形参区分。 int func(int); int func(const int); //重复声明 int func_(int*); int func_(int* const); //顶层const,重复声明 底层const可以实现重载 int func(int &); int func(const int &); //合法重载，常量引用 int func_(int*); int func_(const int*); 底层const只能传给const。由于非常量可以转换为const，非常量引用、指向非常量的指针可以作用于以上四个函数，在调用时，编译器将非常量的参数优先调用非常量的重载函数。 const_cast与重载 //常量引用版本 const string &shorter_string(const string &s1, const string &s2){ return s1.size()(s1), const_cast(s2)); return const_cast(r); } 调用重载的函数 函数匹配（function matching），又叫重载确定（overload resolution） 把函数调用与一组重载函数中的某一个关联起来。将调用的实参与重载集合中的每一个函数的形参进行比较，再根据比较结果决定调用哪个： 找到一个与实参最佳匹配的（best mtach）的函数，生成调用的代码。 找不到任何一个匹配，编译器发出无匹配（no match）的错误。 有多于一个的函数可以匹配，但每一个都不是明显更好的选择。发生错误，二义性调用（ambiguous call） 重载与作用域 如果在内层作用域声明名字，将隐藏外层作用域中的同名实体。不同作用域中无法重载。 #C++中，名字查找发生在类型检查之前。 函数匹配 选定候选函数：与被调用函数同名，且在调用点函数声明可见 考察本次调用的实参，选出能被这组实参调用的可行函数：1.形参数量与本次调用提供的实参数目相同；2.每个实参的类型与形参的类型相同，或者能转换为形参的类型。【如果有提供默认参数，那么实参数目可以少于形参数；若找不到可行参数则编译器报错】 试图从可行函数中寻找最佳匹配，寻找形参形式与实参类型最匹配的可行函数。若有多个形参，最佳匹配需要满足 每个实参都不劣于其他可行函数需要的匹配 至少有一个实参匹配优于其他可行函数提供的匹配 若不满足，则存在二义性调用（ambiguous call） 例 //声明 void f(int a, int b); void f(double a, double b); //二义性调用，无最佳匹配 f(2, 3.14); 类型提升：小类型往往被提升到int，参数是小类型反而可能导致类型转换而不成为优先匹配 算数类型转换的匹配：所有算数类型转换级别一致，对于double转为float或long，优先级一致 "},"C++/chang-jian-ji-zhong-yao-wen-ti.html":{"url":"C++/chang-jian-ji-zhong-yao-wen-ti.html","title":"常见重要问题","keywords":"","body":" C++常见重要问题 关键字 const & static const const关键字用来修饰（声明）变量，则表示变量是一个常量，不可修改，所以这个变量也必须初始化。对于一些在程序运行过程中不应该被修改的变量，应该加const予以保护。 问：为什么不用marco？ 答：const变量是一个变量相比marco更安全，因为他是有类型的，在参数传递的时候可以进行类型检查。 对于类的成员函数而言，加上了const关键字则表明这个成员函数可以被常量对象调用，也可以被非常量对象调用。如果不加的话则只能被非常量对象调用。【可以用来重载类成员函数，可以实现非常量以及常量版本】。注意，如果要返回对象的引用，那么常量版本和非常量版本的返回类型不同。 class A{ A& func(){}; const A& func() const {}; } 作为函数参数，顶层const会被忽略 static 面向过程的：静态变量/函数 静态全局/局部变量的生命周期都是程序的运行期间，存储在全局数据区的内存中，若没有初始值则自动初始化为0。 静态全局变量只在当前文件可用，文件内都可见这个变量；静态局部变量，只在当前语句块内可见（作用域），在首次到达时初始化。 静态函数：只在当前文件内可用 面向对象：类的静态成员 依赖于类，不依赖于具体对象，对象中不包含任何与类静态成员有关的数据，可以使用作用域访问： ::，::() 也可以用对象来访问：.，.()（指针同理） 访问遵循public, private, protected规则 在外部定义、初始化静态成员时，不能重复static关键字，static只能在内类出现。 class Bar{ static int a; static void fff(); } int Bar::a = 1; //定义并初始化,private对象的初始化可以直接进行 void Bar:::fff(){ ///... }; 类的静态成员变量 只有一份数据，存储在全局数据区，生命周期是整个程序运行期间。类以及类的所有对象共享。 一般在类外部初始化，也可以在类内初始化（建议在类外也定义），但是必须为字面值常量。 类的静态成员函数 不包含this指针 在类外定义时，不加static关键字 可以调用访问静态成员（数据、函数），但是不能访问非静态成员 可以被非静态成员访问 好处 可以所有对象共享 不进入全局命名空间 可以实现信息隐藏 可以用于特殊场合 静态数据成员可以是不完全类型（如当前类的数据成员），而普通数据成员不能是不完全类型（普通指针成员可以是） class Bar{ public: //... private: static Bar mem1; //合法，静态成员可以是不完全类型 Bar *mem2; //合法，普通指针成员可以是不完全类型 Bar mem3; //不合法，普通成员必须是完全类型 } ​ 参考：知乎 sizeof inline 内联函数在编译过程中会由编译器将内联函数的代码在调用点展开并替换为函数代码，因此在运行时没有实际调用函数。而我们在使用inline关键字的时候，只是建议编译器进行内联。 好处： 内联函数更快，因为您不需要在堆栈上推送和弹出内容，如参数和返回地址，避免参数拷贝。 可重用，减少代码重复，且修改方便。 本身是一个函数，会检查参数问题，更安全（可与#define宏相比） 内联函数应该在头文件中定义，这一点不同于其他函数。编译器在调用点内联展开函数的代码时，必须能够找到 inline 函数的定义才能将调用函数替换为函数代码，而对于在头文件中仅有函数声明是不够的。 参考：stackoverflow:Benefits of inline function in C++ ，When use Inline 操作符 ++iter; 与 iter++; new与malloc的区别： new(new operator)是C++的关键字，而malloc是C语言标准库的函数。 主要区别： malloc只负责申请空间，并返回一个void*指针；而new会申请空间，并调用构造函数，返回一个相同类型的指针。 malloc在调用时还需指定空间大小。 malloc从堆申请空间，而new从自由存储区申请空间（依赖于operator new的实现） 处理数组时，可以使用new A[n]这样的语法来申请，而malloc需要指定(A*)malloc(sizeof(A)*n) new(new operator)不可重载，而operator new可以重载。（注意区别） malloc可以用realloc重新分配内存，new不行 new/new[]与delete/delete[]搭配；malloc与free搭配。 new的主要功能： 申请内存(operator new, 或者 operator new[]) 调用对象构造函数 返回指向对象的指针 与此相比 delete： 调用析构函数 回收内存(operator delete, 或operator delete[]) 异常情况 malloc申请失败返回NULL new失败抛出bad_alloc异常，可以使用new_handler处理错误，也可以忽略(nothrow)。 参考： 细说new与malloc的10点区别 In what cases do I use malloc vs new? operator new和operator new[]区别？ C++之operator new 和new operator区别 类与继承 多态与虚函数 虚基类，虚继承 虚基类 虚继承 虚函数/纯虚函数，虚函数表 虚函数/纯虚函数/虚函数表 虚函数表 面向对象 三大特征，五大基本原则 C++标准库 C++标准库，C++ Standard Library，是类库和函数的集合，由c++标准委员会制定，并不断维护更新。标准程序库提供若干泛型容器、函数对象、泛型字符串和流（包含交互和文件I/O），支持部分语言特性和常用的函数，如开平方根。C++标准程序库也吸收了ISO C90 C标准程序库。标准程序库的特性宣告于std名字空间之中。std命名空间是C++中标准库类型对象的命名空间 STL（标准模板库，英文：Standard Template Library，缩写：STL），是一个C++软件库，大量影响了C++标准程序库但并非是其的一部分。其中包含4个组件，分别为算法、容器、函数、迭代器。实现了基于模版的数据结构和算法。 联系：标准库大量参考了并基于标准模板程序库（STL）所创建的习惯用法，包含容器、算法、迭代器、函数对象等。 参考：WIKI：C++标准库，WIKI：STL，C++标准库/STD/STL等的区别 智能指针 百度C++提前批 C++后台开发校招面试常见问题 "},"Java/suan-fa-jing-yan.html":{"url":"Java/suan-fa-jing-yan.html","title":"算法经验","keywords":"","body":"算法经验 二分法 有两种计算中值 m 的方式： m = (l + h) / 2 m = l + (h - l) / 2 l + h 可能出现加法溢出，最好使用第二种方式。 "},"Data-structure-and-algorithm/er-cha-shu.html":{"url":"Data-structure-and-algorithm/er-cha-shu.html","title":"树","keywords":"","body":"树的递归定义 树为节点集合，若节点非空，则有由一个根节点和0个或多个非空的（子）树组成，每个子树的根都被来自根r的一条有向边所连接。 树叶、兄弟、父亲、祖先、后裔 路径：从节点n1到nk的path定义为节点n1,n2,n3,…,nk的一个序列：使得1 深度：根到ni的唯一路径的长，（根的深度为0） 高度：ni到一片树叶的最长路径的长。所有树叶高度为0，一棵树的高等于根的高 内部路径长：所有节点的深度。 遍历二叉树（traversal） BFS，队列 按层：往往要求获取层数信息（维护两个last变量，一个指向当前层，一个指向下一层） https://leetcode.com/problems/binary-tree-level-order-traversal DFS，栈 递归的函数上下文栈，或者循环+栈。递归简单清晰，应练习非递归的循环遍历方法 先序遍历(pre-order)：遍历顺序：节点->左儿子（子树）->右儿子（子树） https://leetcode.com/problems/binary-tree-preorder-traversal/ 中序遍历(in-order)：左儿子（子树）->节点->右儿子（子树） 有意思的是，将N个点插入到二叉查找树，再执行中序遍历输出N个点的排序结果。（从中序遍历和二叉查找树的定义可理解，复杂度为O(NlogN)O(NlogN)O(NlogN)） https://leetcode.com/problems/binary-tree-inorder-traversal/ 后序遍历(post-order)：左儿子（子树）->右儿子（子树）->节点 https://leetcode.com/problems/binary-tree-postorder-traversal/ （先序）序列化： 加入空字符#、结束字符！ 反序列化： 由输入字符串->vector \"12!3!#!#!#!\" -> [\"12\",\"3\",\"#\",\"#\",\"#\"] 二叉查找树：Binary search tree 定义：每个节点都有其关键字值，对于树中每个节点X，其左子树中所有节点关键字值都小于X的，右子树所有节点的关键字值都大于X的。 树的任意点期望深度为O(logN)O(logN)O(logN)，平均操作【insert, find, findmin, findmax, delete】复杂度为O(logN)O(logN)O(logN)。 删除操作会破坏这种平均特性，由于删除时，把右子树的最小节点代替原节点，有助于使得左子树比右子树更深。 已证明，交替插入删除Θ(N2)\\Theta(N^2)Θ(N​2​​)次，期望深度将为Θ(N)\\Theta(\\sqrt N)Θ(√​N​​​)。 可通过交替选取右子树最小、左子树最大元素来代替被删节点来消除。 若向预先排序的树输入数据，一连串insert花费二次时间，链表实现代价很大，树由那些没有左儿子的节点组成。 解决方法：附加条件“平衡” AVL树 带平衡条件的二叉查找树，保证树深度为O(logN)O(logN)O(logN) 定义：每个节点的左子树和右子树的高度最多差1的二叉查找树。（空树高度为-1） 插入可能破坏条件，通过“旋转”来修正。插入之后，只有插入点到根节点的平衡可能被改变（只有这些节点的子树可能发生改变），沿此路径上行并更新平衡信息。 旋转操作： 找出第一个破坏AVL条件的节点α（最深的节点），并重新平衡。 四种情况（WHY？，α的左右子树高度差4，若插在左/右儿子则高度差不可能为2，α不可能为第一个破坏点）： 对α的左儿子的左子树插入 对α的左儿子的右子树插入 对α的右儿子的左子树插入（与2.对称） 对α的右儿子的右子树插入（与1.对称） 通过单旋转、双旋转来解决。实现可递归定义插入、左/右的单/双旋转。 单旋转（左-左/右-右） 双旋转（左-右/右-左） 伸展树（Splay Tree） 放弃平衡条件，允许任意深度，但每次操作之后调整； 连续M次操作平均最坏情况O(MlogN)O(MlogN)O(MlogN)，无法保证任意一次操作花费O(N)O(N)O(N)的可能。 对于二叉查找树最坏情况 O(N)O(N)O(N)，若要求最差情况O(MlogN)O(MlogN)O(MlogN)则节点被访问之后必须被移动，否则一直访问最坏节点则有O(MN)O(MN)O(MN) 基本想法：当一个节点被访问后，经过一系列AVL树的旋转被构造到根节点。若该点很深，则路径上的许多存在节点也相对比较深，重新构造可以使得对这些节点的访问时间变少。（实际上，一个节点被访问之后，可能不久再次被访问） 不保留高度或平衡信息 平衡方法 直接单旋转，对最坏情况复杂度为O(MN)O(MN)O(MN) ，因此不可行。 展开操作：XXX为目标节点，若其父为根节点，直接单旋转。否则分为以下情况 之字形（Zig-zag），即采用AVL的双旋转 一字型（Zig-zig） B-Tree 定义：B-树是平衡M-路树；对于阶为MMM的B-树，有如下 树的根，或为叶子节点，或有222到MMM个儿子 除了根以外，所有非叶子节点（内部节点）的儿子数在⌈M/2⌉\\lceil M/2\\rceil ⌈M/2⌉和MMM之间。 所有树叶在相同深度上，所有的数据都存储在树叶上。（数据本身，或指向数据的指针） 在每一个内部节点上，有如下： 指针：指向该节点的各个儿子（子树），P1P_1P​1​​,P2P_2P​2​​,P3P_3P​3​​,...,PMP_MP​M​​ 内部信息：分别代表子树P2P_2P​2​​, P3P_3P​3​​,...,PMP_MP​M​​中发现的最小关键字的值，k1k_1k​1​​,k2k_2k​2​​,k3k_3k​3​​,...,kM−1k_{M-1}k​M−1​​。（第一个子树由于在最左侧，没有比它更小的子树，因此不需要存储它的最小关键字值） 例：3阶B-树（又称为2-3树） 图例：椭圆为内部节点，椭圆内的数表示内部信息（子树的最小关键字值）。方框为树叶，其中数字表示关键字的值（此处为数据）。 由于最左侧的子树的最小关键字值是不需要存储的，有n个儿子的情况下只需存储n-1个值。因为是3阶的B-树，对于三个儿子的情况需要存储2个内部信息值（见节点41:58），对于2个儿子则只需要存储一个信息值（见16:-和22:-）。 插入 对于尚未见过的关键字值XXX执行Insert，先按Find找到一片树叶，插入到该位置。若插入后破坏了B-树性质（树叶包含数据超过MMM），则执行“分裂”，向上一层增加一个节点（若上一层增加后又破坏B-树的性质，则递归向上分裂）。此外，也可以不执行“分裂”，如向上图插入70，可以移动58到左侧树叶。 需要注意，插入时只有访问路径上的内部节点才有可能变化。 复杂度 深度最多为⌈log⌈M/2⌉N⌉\\lceil log_{\\lceil M/2\\rceil}N\\rceil⌈log​⌈M/2⌉​​N⌉ 对于路径上每一个节点，要执行O(logM)O(logM)O(logM)时间的工作来确定分支路线（二分查找） Insert和delete可能还需要O(M)O(M)O(M)的工作量来更新调整节点上的所有信息，因此最坏情况为O(MlogMN)=O((M/logM)logN)O(Mlog_{M}N)=O((M/log_{M})logN)O(Mlog​M​​N)=O((M/log​M​​)logN)，不过一次Find只花费O(logN)O(logN)O(logN) 时间 应用：数据库系统 树存于物理磁盘而非内存。 磁盘访问次数为O(logMN)O(log{M}N)O(logMN)， 虽然要花费O(logM)O(logM)O(logM)时间来确定分支，但仍比读存储器快得多。 每个节点更新花费O(M)O(M)O(M)操作时间，这些花费一般不大（WHY？） MMM值一般选择为，使得一个内部节点能够装入一个磁盘区块的最大值。 存储在一片树叶上的元素的最大个数时，要使得树叶是满的那么它就装满一个区块。 "},"Data-structure-and-algorithm/sort.html":{"url":"Data-structure-and-algorithm/sort.html","title":"排序算法","keywords":"","body":" 常见排序方法 冒泡排序、选择排序、插入排序、归并排序、快速排序、堆排序 开始之前 先编写交换元素的函数，以便后续排序时调用。都声明为inline，减少调用开销。 //下标形式的 inline void swap(vector &v, int i, int j){ int tmp = v[i]; v[i] = v[j]; v[j] = tmp; return; }; //迭代器形式的 inline void swap(vector::iterator i1, vector::iterator i2){ int tmp = *i1; *i1 = *i2; *i2 = tmp; return; }; 冒泡排序 /* * bubble sort */ void vbubble_sort(vector &v){ int len = v.size(); for(int i = len-1; i>=0; --i) for(int j = 0; jv[j+1]) swap(v,j,j+1); return; } 选择排序 /* * selection sort */ void selection_sort(vector &v){ int len=v.size(); for(int i=len-1; i>0; --i){ //find max int max=INT_MIN, max_id=0; for(int j=0; jmax){ max_id = j; max = v[j]; } } swap(v,max_id,i); } return; } 插入排序 /* * insert sort */ void insert_sort(vector &v){ int len=v.size(); int left=0, right; for(right=1; right=1 && value 归并排序 /* * merge sort */ void merge_sort_recursive(vector::iterator beg, vector::iterator end){ if(beg+1>=end) return; auto middle = beg + (end-beg)/2; merge_sort_recursive(beg,middle); merge_sort_recursive(middle, end); vector tmp_v(beg,end); auto t1 = tmp_v.begin(); auto t2_end = tmp_v.end(); auto t1_end = t1 + (t2_end - t1)/2, t2 = t1_end; while(t1 != t1_end && t2 != t2_end){ if(*t1 &v){ merge_sort_recursive(v.begin(), v.end()); return; } 上面的代码实际上可以优化，主要问题在于每次迭代都重新申请一个数组，并且进行了复制。反复的申请空间可能造成额外的开销，可以一次申请一个同原数组一样的的临时数组，然后复用两个数组的空间。 //One temp array version void merge_sort_recursive_t(vector::iterator beg, vector::iterator end, vector::iterator t_beg, vector::iterator t_end){ if(beg+1>=end) return; auto middle = beg + (end-beg)/2; auto t_middle = t_beg + (end-beg)/2; merge_sort_recursive_t(t_beg, t_middle, beg, middle); merge_sort_recursive_t(t_middle, t_end, middle, end); //merge auto t1 = beg; auto t2 = middle; while(t1 != middle && t2 != end){ if(*t1 &v){ //merge_sort_recursive(v.begin(), v.end()); vector tmp(v.begin(), v.end()); merge_sort_recursive_t(tmp.begin(), tmp.end(), v.begin(), v.end()); return; } 快速排序 /* * quick sort */ void quick_sort_recursive(vector::iterator beg, vector::iterator end){ if(beg+1 >= end) return; //这里选第一个元素的值作为中间值 //实际上也可以选择其他位置的元素，为了方便修改保留了这个变量。 auto key = beg; auto middle = *key; auto l_end = beg, curr = beg; //swap key and the last exchange_ele(key, end-1); while(curr != end-1){ if(*curr &v){ quick_sort_recursive(v.begin(), v.end()); return; } 堆排序 /* * Heap sort */ void siftdown(vector &v, int i, int len){ //for i (start from 0 to n-1 ) //left : 2*i + 1 //right : 2*i + 2 //father : (i-1)/2 int son = 2*i + 1; if(son>=len) return; if((son+1) v[son] ) ++son; if(v[i]>= v[son]) return; swap(v, i, son); //recursive return siftdown(v, son, len); } void heap_sort(vector &v){ //sift down from the last father to the root //O(N) for(int i=(v.size()-2)/2; i>=0; --i) siftdown(v,i,v.size()); //O(NlogN) for(int i=v.size()-1; i>0; --i){ swap(v,0,i); //the last element swap to the first //then go down. siftdown(v,0,i); } return; } 参考： https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F "},"Data-structure-and-algorithm/suan-fa-xi-ti.html":{"url":"Data-structure-and-algorithm/suan-fa-xi-ti.html","title":"算法习题","keywords":"","body":" Leetcode & 剑指offer题 字符串 链表 反转链表 OJ：牛客， Leetcode[easy] 非递归方法 保存两个指针，一个prev 指针指向当前元素的前驱，一个当前指针curr（可用pHead代替）。用到临时指针nex用作交换。 时间复杂度：O(N) O(N) O(N) 空间复杂度：O(1) O(1) O(1) class Solution { public: ListNode* ReverseList(ListNode* pHead) { ListNode *prev = nullptr, *curr = pHead, *nex; while(curr){ nex = curr->next; curr->next = prev; prev = curr; curr = nex; } return prev; } }; 递归方法 时间复杂度：O(N) O(N) O(N) 空间复杂度：O(1) O(1) O(1) （考虑到递归调用的栈开销，使用了尾递归，编译器应该可以进行优化。Leetcode的subbmission显示内存占用与跟非递归的基本一致） class Solution { private: ListNode *reverseList_recursively(ListNode *prev,ListNode *curr){ if(!curr) return prev; ListNode *nxt = curr->next; curr->next = prev; return reverseList_recursively(curr, nxt); } public: ListNode* reverseList(ListNode* head) { return reverseList_recursively(nullptr,head); } }; PS，显然这里没太大必要使用递归方法，毕竟还有额外的调用开销 上面的代码在Leetcode提交，递归版本运行时间为16ms，而非递归仅需要8ms 从尾到头输出链表 OJ：牛客 由于单向链表无法反向遍历，因此自然可以想到利用栈（先进后出）来解决。 栈的利用，可以通过递归调用来达到，也可以自己对栈进行操作。 递归实现 时间复杂度：O(N) O(N) O(N) 空间复杂度：O(N) O(N) O(N)，（因为调用栈深为N） class Solution { private: void TraversalFromTail_Recursive(vector &vi,ListNode* curr){ if(!curr) return; TraversalFromTail_Recursive(vi, curr->next); vi.push_back(curr->val); return ; } public: vector printListFromTailToHead(ListNode* head) { stack stk; vector arr; TraversalFromTail_Recursive(arr, head); return arr; } }; 调用栈结构实现 时间复杂度：O(N) O(N) O(N) 空间复杂度：O(N) O(N) O(N)，（因为栈深为N） class Solution { public: vector printListFromTailToHead(ListNode* head) { stack stk; vector arr; while(head){ stk.push(head); head = head->next; } while(!stk.empty()){ head = stk.top(); stk.pop(); arr.push_back(head->val); } return arr; } }; 也有方法为使用vector，顺序存储后，再inverse（调用stl函数） 删除有序链表中的重复结点 问题描述：Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 Input: 1->2->3->3->4->4->5 Output: 1->2->5 OJ：牛客，Leetcode[medium]。（此外还有简化版，保留一个重复出现过的结点，见Leetcode[easy]） 思路：保留两个指针，一个指向重复的开头，一个指向连续重复结点的尾部，中间全部的节点都需要删除。 由于是排序链表，实际上只需在第一次遇到重复结点时(curr->next)->val == curr->val，保留第一个指针curr不动（实际需要保留前驱prev），第二个指针right不断后移直至遇到非重复结点，这时就可以执行删除。 实际编程考虑到可能从头结点开始删除，为编程方便定义哑结点dummy 开始时prev指向dummy，这样不需要分类判断。 class Solution { public: ListNode* deleteDuplication(ListNode* pHead) { if(!pHead) return pHead; ListNode dummy(0); dummy.next = pHead; ListNode *prev = &dummy, *curr=pHead; while(curr->next){ if((curr->next)->val != curr->val){ prev = curr; curr = curr->next; }else{ ListNode *right = curr->next; int val = curr->val; while(right && right->val == val) right = right->next; prev->next = right; //delete ? curr = prev; } } return dummy.next; } }; 树 层序遍历 中序遍历 后序遍历 求二叉树的最大深度 OJ：牛客，Leetcode[easy] 求树的最大深度需要遍历整棵树，因为遍历完毕之前，总有可能存在存在一条未走完的路径比当前最长路径更长。 直观的想法是，直接遍历树，并维护一个最深的叶子的深度，不断更新。 实际上，由定义可知当前节点的深度curr = 1 + max(left, right); 递归计算树的深度（深度优先搜索DFS遍历方法） 时间复杂度：O(N) O(N) O(N)，（由于遍历的缘故） 空间复杂度：O(N) O(N) O(N)，（考虑最坏情况，树的节点只有左或右儿子，那么递归深度为N） class Solution { public: int TreeDepth(TreeNode* pRoot) { if(!pRoot) return 0; int dep_l = TreeDepth(pRoot->left); int dep_r = TreeDepth(pRoot->right); return (1 + (dep_l>dep_r? dep_l : dep_r)); } }; 此外，前文提到，可以直接遍历树，维护一个最深叶子深度。想一想，遍历方法中分为DFS和BFS，而DFS可以使用上述的递归方法求。对于BFS，实际上层序遍历可以通过队列实现，并且通常需要判断换层操作。那么只需要统计换层的次数，最后就可以知道整棵树的深度。 非递归计算树的深度（广度优先BFS遍历方法） 时间复杂度：O(N) O(N) O(N)，（由于遍历的缘故） 空间复杂度：O(N) O(N) O(N)，（考虑完全二叉树，最后一层或倒数第二层，队列中有O(N/2) O(N/2) O(N/2) 以及 O(N/4) O(N/4) O(N/4) 个节点） class Solution { public: int TreeDepth(TreeNode* pRoot) { queue q; int deep= 0; TreeNode *last = pRoot, *nlast; if(pRoot) q.push(pRoot); while(!q.empty()){ TreeNode *cur = q.front(); q.pop(); if(cur->left){ q.push(cur->left); nlast = cur->left; } if(cur->right){ q.push(cur->right); nlast = cur->right; } if(cur == last ){ ++deep; last = nlast; } } return deep; } }; 求二叉树最小深度 Leetcode[easy] 题目与上面类似，区别在于求最小深度可以提前终止搜索。因此，采取BFS更合理。 其他 "},"computer-network/networkbasic-definition.html":{"url":"computer-network/networkbasic-definition.html","title":"基本定义","keywords":"","body":" 计算机网络基本定义 网络：若干节点node（计算机、集线器、交换机或路由器）和连接节点的链路link组成。 互联网：network of networks 因特网：全球最大的互联网 边缘部分：主机组成，用户直接使用 主机A与主机B通信：主机A的某个进程和主机B上的另一个进程通信 端系统之间的通信方式可分为： 客户端（client）-服务端（server）方式：指通信涉及的两个应用进程，客户端请求服务（发起通信），服务端提供服务。 对等连接（peer to peer，P2P）：两个主机通信时不区分谁是服务提供方、请求方。两个主机都运行P2P软件，则平等、对等通信。 核心部分：大量网络和连接网络的路由器组成，为边缘提供服务 路由器，实现分组交换（转发分组，分组为报文的一部分） 按照范围、使用者划分的几个网络定义： WAN（广域网），LAN（局域网），PAN（个人域网） 公用网，专用网 指标 速率：（数据率、比特率）传输数据的速率，bit/s 带宽：最高数据率 吞吐量：单位时间内通过网络的数据量 时延/延迟：发送时延、传输时延、处理时延、排队时延 时延带宽积： = 传播时延x带宽，又称为以比特为单位的链路长度 往返时间RTT：发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间。 利用率：信道利用率、网络利用率（两者不同）。信道或网络利用率过高，会产生很大的延迟。对于网络利用率和延迟的关系，D=D0/(1−U)D=D_0/(1-U)D=D​0​​/(1−U)，其中DDD为延迟，D0D_0D​0​​为空闲时的延迟，UUU是利用率。 协议与层次 规定交换数据的格式以及有关的同步问题 协议是水平的，控制两个对等实体进行通信，使得本层能够向上一层提供服务，使用本层协议需要下一层所提供的服务。下层协议对上面的实体是透明的，只有能被实体看见的才称为服务。 分层 各层独立，灵活性好，结构上可分割开，易于实现和维护，促进标准化工作 各层完成的功能（一种或多种，同一个功能在不同层次可能会反复出现）： 差错控制 流量控制 分装和重装（数据块划分为更小的单位，在接收端将其还原） 复用和分用（几个高层会话复用一条低层连接，在接收端将其还原） 连接建立和释放 模型 五层简介 各层的传输单元都可以称为分组，在OSI模型中成为PDU(Protocol Data Unit) 应用层(application layer) 通过应用进程的交互来完成特定网络应用，应用进程通信和交互的规则【HTTP、SMTP、FTP】 数据单元：报文(message) 传输层(transport layer) 向两个主机中进程之间的通信提供通用的数据传输服务 通用：不针对某个应用，多个应用可使用同一个传输层服务【复用、分用】 TCP(Transmission Control Protocol)面向连接、可靠的数据服务，传输单元：报文段(segment) UDP(User Datagram Protocol)无连接的、尽最大努力(best-offer)的数据传输服务，不保证可靠性，传输单元：用户数据报 网络层(network layer) 为分组交换网的不同主机提供通信服务。发送数据时，把报文段、用户数据报封装为分组或包(packet)进行传送。 TCP/IP中使用IP协议，分组又称为IP数据报，或简称数据报(Datagram) 另一个功能：路由决策，使得传输层接下来分组可以通过网络中的路由器找到目的主机 数据链路层(data link layer) 负责链路上两个相邻节点之间的数据传输（字节流），将IP数据报组装成帧(frame)，帧包括控制信息，以便接收端提取数据给上一层 检错、纠错功能 物理层(physical layer) 提供透明传输比特流的功能， "},"computer-network/networktcp-udp.html":{"url":"computer-network/networktcp-udp.html","title":"TCP/UDP","keywords":"","body":" TCP、UDP是传输层的服务，为应用进程提供通信。 重要概念 传输层为互相通信的应用进程提供逻辑通信（端到端） 端口(port)与套接字(socket) 无连接的UDP，不可靠信道 面向连接的TCP，全双工的可靠信道 在不可靠网络上实现可靠传输的原理，停止等待协议、ARQ协议 TCP的滑动窗口、流量控制、拥塞控制和连接管理 运输层的端口 运输层从IP层收到数据后，需要交付给特定应用进程，因此需要标志运行在应用层的各种应用进程。为了不同OS的应用进程可以互相通信，需要用统一的方法（与OS无关）标志。 协议端口号（端口，port） TCP/IP使用16位的端口（65535个），TCP和UDP的首部都有源端口和目的端口，端口是标志本计算机应用层的各个进程与传输层交互的层间接口，只具有本地意义。通信时需要知道对方IP地址、端口 端口分类 服务器使用端口 熟知端口号、（系统端口号）：0-1023 登记端口号：没有熟知端口的应用程序使用，1024-49151 客户端使用的端口号（短暂端口号） 49512-65535，客户端进程运行时动态选择，暂时使用 UDP 无连接的 尽最大努力交付 面向报文，发送方的UDP对应用程序交下的报文，添加首部后就交付给IP层，不合并也不分拆。一次交付一个完整的报文。 没有拥塞控制，拥塞不会降低发送速率。对于实时的应用，要求主机以恒定速率发送数据，可以容忍丢失但是对延迟敏感，使用UDP。 支持一对一、一对多、多对一、多对多的交互通信 首部开销小（8个字节） UDP的首部格式 每个字段2字节 源端口，不需要对方回信时可全0 目的端口 长度，最小值为8（仅有首部） 校验和 接收方从IP层收到UDP数据报时，根据目的端口分发给应用进程。 若接收方UDP发现收到的报文中的目的端口不正确（不存在对应这个端口的应用进程），则丢弃报文，使用ICMP发送“端口不可达给发送方” 校验和 计算时要加入伪首部，伪首部仅用于计算校验和而不向上或向下传递，计算校验和的部分包括：伪首部、首部、数据部分。同时检查了包括IP数据报源地址、目的地址（伪首部），UDP源端口、目的端口（UDP首部），以及UDP数据部分。 TCP 面向连接的传输层协议：应用使用之前必须先建立连接，传输完毕后必须释放已建立的TCP连接。 每条TCP连接只能有两个端点，是点对点的 提供可靠交付服务 全双工通信，设有发送、接收缓存 面向字节流，TCP的“流”指的是流入到进程或者从进程流出的字节序列。但TCP传输单元是报文段。 TCP并不关心应用进程一次将多长的报文发送到TCP缓存中，而根据对方给出的窗口值、网络拥塞程度决定一个报文段要包含多少个字节。 TCP的连接 TCP连接的端点是socket 套接字socket=(IP地址:端口号) TCP连接 ::= {socket1,socket2} = {(IP1:port1), (IP2:port2)} 同一个IP地址可以有多个不同的TCP链接，同一个端口号也可以出现在多个不同的TCP连接中 可靠传输原理 TCP下层不提供可靠传输，需要协议实现： 出现差错时，让发送方重传出现差错的数据。（实际信道会产生差错） 接收方来不及处理数据时，告知发送方降低发送速率。（实际接收方处理速度有限） 停止等待协议 发送完一个就停止并等待对方的确认，收到确认在发送下一个分组。 超时重传：超过一段时间没有收到确认，就认为丢失了，则重新发送分组。（需要设置超时器） 发送完毕后，需要保留分组副本 分组和确认分组，都需要进行编号 超时器设置的重传时间，应该比平均RTT更长一些。 确认丢失：接收到分组后，又收到了重传的同一个分组。 丢弃这个重复的分组 向对方发送确认（不能认为已发送过确认，就不再发送） 确认迟到：收到重复的确认，并丢弃 使用以上确认、重传机制，可以实现可靠的通信。（ARQ：Automatic Repeat reQuest） 信道利用率：利用率很低，解决方法：流水线传输，连续ARQ协议和滑动窗口协议 连续ARQ协议 发送方：维持发送窗口，每收到一个确认则把发送窗口前移一个分组的位置。 接收方：累计确认，不对每一个收到的分组都发送确认，对按序到的的最后一个分组发送确认。 基础版本：Go-back-N，发送方发5个分组，第三个丢失了，但他不知道后两个是否到达，必须重退到第3个开始发送 TCP报文的首部 前20字节固定，后面有4n字节是根据需要而增加的选项。头部最长60字节（受限于数据偏移字段长度，20 + (2^4 - 1)* 4Byte） 源端口、目的端口 序号，4字节，传输的字节流中，每一个字节按顺序编号（mod 2^32），首部中的值是本报文段发送的数据的第一个字节的序号（头部序号字段是301，携带100个字节，则最后一个字节序号是400）。初始序号，在连接建立时设置。 确认号，4字节，是期望收到对方下一个报文段的第一个数据字节的序号。（若收到301-400的报文段，则确认报文的确认号为401） 确认号为N，则N-1为止的所有数据都已正确收到。 数据偏移，即报文段起始距离数据的距离，也就是首部长度。 保留 紧急URG，置1表示有效 确认ACK（ACKnowlegment），连接建立后所有报文都置为1 推送PSH 选项复位RST， RST == 1时，表明TCP连接出现严重错误，必须释放连接再重新建立连接。也用于拒绝非法报文段，或拒打开连接。 同步SYN，用于连接建立时同步序号，当SYN==1且ACK==0是连接请求报文段，若对方同意建立连接则响应报文使SYN==1和ACK==1。（SYN置为1则表明，是一个连接请求或连接接受报文） 窗口，2字节，范围为[0, 2^16-1]，指发送本报文段的一方的接收窗口。告诉对方：从本报文段首部中的确认号起，接收对方目前允许对方发送的数据量。接收方让发送方设置其发送窗口的依据。 指出现在允许对方发送的数据量，窗口值经常处于动态变化中 校验和，2字节，校验范围包括首部和数据。跟UDP一样，添加12字节伪首部计算，不同的是TCP的伪头部第四个字段改为6，第五个字段改为TCP长度。 紧急指针 选项 窗口扩大（2^16 Byte = 64KB，对于目前网络而言太小） 时间戳（计算RTT，高速网络解决序号绕回） 选择确认SACK 最大报文段长度MSS，数据字段最大长度 TCP的可靠传输实现 根据通信对方的确认报文段的窗口值调整滑动窗口（以字节为单位）。 假设A向B单向通信，窗口变化存在以下情况： 窗口向前移动，收到确认报文（且窗口值不会太小） 窗口不移动 没有收到新的确认，对方通知的窗口大小也不变。（窗口前沿不动） 收到新的确认，但窗口缩小了，使得窗口前沿正好不动 窗口不会往后移动，因为已确认接受的确认不可撤销 发送窗口：图中的P3 - P1 可用窗口/有效窗口：图中的P3-P2，允许发送但尚未发送的字节数 TCP缓存 发送方将字节流写入TCP发送缓存，接收方从TCP缓存接收数据 缓存空间、序号空间都有限，是循环使用的 窗口是缓存的一部分，发送程序不应该发送过多数据否则缓存不足，同样接收程序应及时接收数据。 发送缓存中的数据： 发送程序传送给TCP准备发送的数据 TCP已发出但没收到确认的数据 接收缓存中的数据： 按序到达、尚未被应用程序接收的数据 未按序到达的数据 超时重传的时机选择 超时重传时间太短，则频繁重传；太长，则网络空闲时间增加，传输效率低。 TCP采用自适应算法，根据报文段往返时间RTTRTTRTT（报文段发送时间——接收响应确认的时间），并保留加权平均往返时间RTTs RTT_s RTT​s​​ 。权重α\\alphaα的推荐值为1/81/81/8 RTTs=(1−α)∗RTTs+α∗RTT RTT_s = (1-\\alpha)*RTT_s + \\alpha*RTT RTT​s​​=(1−α)∗RTT​s​​+α∗RTT 超时重传时间RTO（Retransmission Time-out）： RTO=RTTs+4∗RTTD RTO = RTT_s + 4*RTT_D RTO=RTT​s​​+4∗RTT​D​​ 其中RTTDRTT_DRTT​D​​ 是RTT的偏差的加权平均值，与RTTsRTT_sRTT​s​​ 和新的RTTRTTRTT样本之差有关，权重β\\betaβ 推荐为0.25 RTTD=(1−β)∗RTTD+β∗∣RTTs−RTT∣ RTT_D = (1-\\beta)*RTT_D + \\beta*|RTT_s - RTT|RTT​D​​=(1−β)∗RTT​D​​+β∗∣RTT​s​​−RTT∣ 然而，上面方法存在一个问题。当出现重传后，收到确认，如何知道确认是对此前哪一个发送的报文的确认？ Karn提出的改进：只要报文段重传了，就不采用它的RTT样本。 这个方法同样存在问题，当延迟突然增加很多的时候，重传时间内无法收到确认，报文段都需要重传，但是由于重传报文不用作更新，超时重传时间不被更新。 改进：只要重传了，就增大RTO。 选择确认SACK 在TCP报文段首部增加SACK选项，告知收到的不连续字节快的边界（一个字节块边界32bit，4字节），以选择性地重传缺少的数据。 TCP的流量控制 流量控制（flow control）：让发送方发送速率不要太快，以便接收方可以及时接收。 rwnd，窗口值（字节为单位） 可能存在死锁：B向A发送零窗口报文段，过一段时间后由于B有缓存空间，再次发送rwnd=400的报文段，但这个报文段丢失。A一直没收到，一直保持0窗口。 解决：持续定时器（persistence timer），只要一方收到零窗口通知，就启动定时器，设置时间到期就发送1字节的探测报文段，对方则给出目前窗口值。 实际上，程序将数据交给TCP缓存之后，由TCP控制，这里有几种发送报文段的时间节点： 数据达到MSS（最大报文段长度）字节后，组成TCP报文段发送 应用程序指明要发送，即PUSH操作 发送方的计时器到期，将缓存装入报文段（不超过MSS）发送出去 存在的情况是，例如交互式TELNET连接，发送一个字节数据，TCP+IP头部共41字节，对方回复40字节（无数据）。仅传输1个字节，要发送2个报文段，共81个字节。应适当推迟发回确认报文，使用捎带确认的方法。 另一个情况是，糊涂窗口综合症，接收方TCP缓存已满，交互式进程每次只读取1个字节，再向发送发发送确认，对方将窗口设为1个字节。而后发送方又发来1个字节数据（IP数据报长41字节），如此循环。网络效率很低。解决方法：接收方等待一段时间，使得接收缓存有空闲（能容纳一个最长报文段，或空闲总共一半的空间） 总的来说，发送方不发送很小报文的同时，接收方也不要急于有一些空间就将很小的窗口通知发送给对方。 TCP的拥塞控制 与流量控制的联系和差别 拥塞控制：是全局性的过程，目的是防止过多数据注入到网络中，避免网络中路由器或者链路过载。前提：网络能够承载现有的负荷。假定：迟迟不收到对方的确认，认为网络中某处可能发生拥塞。 流量控制：控制点对点通信量，是端到端的问题。 两者联系： 有的拥塞控制算法，是向发送端发送控制报文，让其放慢发送速率。 发送方的窗口上限，由流量控制、拥塞控制共同决定： 发送方窗口上限值= Min[rwnd, cwnd] 几种拥塞控制的方法： 慢开始 & 拥塞避免 发送方维持拥塞窗口cwnd ，并动态变化，让发送窗口等于拥塞窗口 慢开始，从很小的值开始，并非增长得慢。（先将cwnd设置为一个MSS的数值）。经历一轮传输后（即，收到对之前已发送的最后一个字节的确认），则将拥塞窗口增大一倍。 为了防止增长过大，设置状态量慢开始门限ssthresh 当cwnd，使用慢开始 当cwnd>ssthresh，使用拥塞避免算法 当cwnd=ssthresh，使用上述两种均可。 所谓拥塞避免算法，是降低增大速率，从指数增长降低为线性增长。 无论是慢开始还是拥塞避免算法，只要检测到拥塞（即没及时收到确认），就将ssthresh设置为拥塞时发送方窗口值的一半（不小于2），并将cwnd设置为1，执行慢开始算法。 将拥塞窗口减少为一半，又称为乘法减小； 线性增加的拥塞窗口，又称为加法增大 快重传、快恢复 实际中，若每次检测到拥塞，就将cwnd调整为1，可能有点过激，因为有可能网络环境较好，只丢失了一个分组，这样调整窗口对网络利用率不高。 快重传算法，是指接收方一旦收到一个失序的报文段，就马上发出重复确认。目的是及时让发送方知道，中间有报文没有及时到达。规定发送方一旦连续受到三个重复确认，就认为丢失了报文段并快速重传，而不等待定时器到期。 快恢复算法，是在发送方连续受到三个重复确认时使用，这种情况下认为网络很可能没有发生拥塞，因为接收方已经收到了连续几个报文。但是为了避免网络拥塞，依然需要乘法减半，但接下来并不执行慢开始： 将慢开始门限ssthresh设置为cwnd的一半（乘法减小） 将cwnd设置为新的ssthresh值，并执行拥塞避免算法（加法增大） 随机早期检测 为了避免路由器队列满时，丢弃所有分组导致大量TCP连接同时进入慢开始状态。在队列满之前（队列较长时）采取随机丢弃分组的方法。 平均队列长度小于最小门限TH_min，新到达分组放入队列尾部 平均队列长度大于最大门限TH_max，丢弃新到的分组 平均队列长度介乎两者之间，按照概率p随机丢弃到达分组 TCP运输连接管理 三个阶段： 连接建立 数据传输 连接释放 TCP采用C-S方式建立连接 连接建立：三次握手 服务端B监听（Listen） 客户端A发生连接请求报文，SYN=1，ACK=0，序号seq=x（SYN报文段不携带数据，但消耗一个序号）。客户端进入SYN_SENT状态 B收到请求，若同意则发送确认。确认报文中SYN和ACK置1，确认号为ack=x+1，同时设置自己的序号seq=y（同样不携带数据，但消耗一个序号）。服务端进入SYN_RCVD状态。 A收到B的确认后，还需发送一次确认报文（第三次握手）。确认报文ACK置为1，确认号ack=y+1，而自己序号seq=x+1。【若这个确认报文不携带数据，则不消耗序号，下一个数据报仍然为x+1】。此时，TCP连接建立，客户端进入ESTABLISHED状态。 B收到A的确认，也进入ESTABLISHED状态 为什么要三次握手？个人理解如下： 因为TCP是面向连接的，至少两次握手（没收到对方确认，无法认为连接已建立） 若只握手两次，那可能存在客户端发送过两次请求，第一次遇到网络拥塞，而第二次先到达并建立连接。此后第一次迟到，而服务端此时再建立一个连接，但是这个连接是无效的，因为客户端认为自己没有发送连接请求。所以在服务端耗多了一个无效连接 连接释放：四次挥手 A发送FIN=1，seq=u的释放报文，进入FIN_WAIT-1状态（FIN报文不携带数据也要消耗一个序号） B收到后，发出确认，确认号ack=u+1，seq=v，并进入CLOSE-WAIT状态。（此时TCP通知应用，A到B方向的连接释放了，而B可能还有数据要发，B到A的连接没释放） A收到B的确认，进入FIN_WAIT-2状态，等待B的释放报文段 B没有数据需要发送了，则应用通知TCP释放连接。发出FIN=1，ACK=1的释放报文，B的序号seq=w，还需要发送确认号ack=u+1。B进入LAST-ACK状态 A收到B的释放报文后，还需要发出确认，将ACK=1，确认号ack=w+1，自己序号为seq=u+1，A进入TIME-WAIT状态。等待时间等待计时器设置的时间2MSL之后，才进入CLOSED状态。 为什么A要等待？ 保证A最后一个确认报文到达B，因为它可能丢失那么B会超时重传FIN+ACK报文段，A收到再次确认并重启定时器。否则B可能无法进入CLOSED状态 防止“已失效的连接请求报文段”，保证本连接的数据已经从网络中消失而不会出现在下一次新的连接中 此外，还有保活计时器（keepalive timer），不让服务器白白等待客户端。每次收到客户端消息会重设这个定时器。 TCP状态机 "},"android/android-studiocha-jian.html":{"url":"android/android-studiocha-jian.html","title":"Android studio插件","keywords":"","body":"常用的Android Studio 插件 AndroidSourceViewer 作用 查看源码 使用 对着class名字右键，点击对应功能 查看该类源码 对比该类与历史版本源码 查看该类官网API文档 "},"android/9.0源码分析笔记/Window.html":{"url":"android/9.0源码分析笔记/Window.html","title":"Window","keywords":"","body":"Window源码分析 参考： 《Android开发艺术探索》 Window的创建过程 Toast的Window创建过程 Toast的视图创建方法 视图对应的是一个View成员变量mNextView 默认会创建一个com.android.internal.R.layout.transient_notification的布局，里面的TextView的id为R.id.message Toast的控制 使用show()和cancel()开控制显示和隐藏，倒计时隐藏采用内置的handler show和cancel内部是通过IPC调用NotificationManagerService来处理 "},"operating-system/processenvironment.html":{"url":"operating-system/processenvironment.html","title":"进程环境","keywords":"","body":"进程环境 进程执行与退出 main函数 C程序总由main函数执行开始 int main(int argc, char **argv); 内核执行程序（唯一方法：使用exec）时，调用main之前先用一个特殊的启动例程，可执行文件将此启动例程指定为程序的起始地址。启动例程从内核获得命令行参数和环境变量值，为按上述方法调用的main函数做准备。 Exit函数 exit函数终止进程，总是执行一个标准I/O库的清理关闭操作（缓冲区数据会被冲刷到文件中），再进入内核。带int参数，表示返回状态。 exit会调用函数（exit handler，终止处理程序），调用顺序与登记顺序相反。登记使用atexit(void (*func)(void))函数。先执行各个终止处理程序，再关闭打开的所有流。 命令行参数 int argc表示参数数目，char **argv以字符串形式各参数 要求 argv[argc] == NULL 存储空间布局 正文段，由CPU执行的机器指令。通常是可共享的，在存储器只有一个副本，只读。 初始化数据段，包含了程序中需要明确地赋予初值的变量。 非初始化数据段，又称BSS段(block started by symbol)，在程序执行之前将此段数据初始化为0或空指针。 栈，自动变量以及每次函数调用所保存的信息都存放在此段中。每次调用函数时，调用者的环境信息（如寄存器）和返回地址都存放在栈中。然后，在栈上为最近被调用的函数的分配自动和变量的存储空间。每次调用，使用一个新的栈帧。 堆，在堆中进行动态内存分配。（由于历史原因处于BSS段和栈之间） 可参考： C/C++堆区、栈区、常量区、静态数据区、代码区详解 C/C++内存管理详解 共享库 执行文件中不需要包含库例程，只需要在可引用存储器中维护一个副本。 在第一次执行或第一次调用某个库函数时，使用动态链接方法将程序与共享库函数相连接。 减少可执行文件长度，但增加时间开销，另外好处是在更新库函数时无需重新链接程序。 存储器分配 三个函数malloc ，calloc ，realloc void *malloc(size_t size); void *calloc(size_t nobj, size_t size); void *realloc(void *ptr, size_t newsize); void free(void *ptr); 返回指针是适当对齐的，可以用于任何数据对象。 通常用sbrk系统调用实现，该调用扩充或缩小进程的堆。但大多数malloc和free都不减少进程的存储空间，释放的空间供以后再分配，通常保持在malloc池中而非返回给内核。 一般分配空间比要求稍大，用于记录管理信息——分配块的长度、指向下一个分配块的指针等。 两种函数 转跳函数 int setjmp(jmp_buf env); void longjmp(jmp_buf env, int val); 可以跨函数转跳（goto 只能函数内转跳），在栈上跳过若干调用帧，返回调用路径上某个函数。 资源限制 int getlimit(int resource, struct rlimit *rlptr); int setrlimit(int resource, const struct rlimit *rlptr); 查询、更改资源限制 "},"operating-system/processcontrol.html":{"url":"operating-system/processcontrol.html","title":"进程控制","keywords":"","body":""},"others/mark.html":{"url":"others/mark.html","title":"Mark","keywords":"","body":"牛客 2.20笔试 选择题： cron后台常驻程序(daemon)用于？crontab 定时任务，每分钟检查一次。 最小生成树 编程题： 存在问题：编码速度太慢 第二题没想清楚，没写完 第三题最短路径，不会。 CVTE-C/C++笔试[2019.3.2] 选择题知识点 static、const函数： 面向对象依赖倒置 STL的atmoic语句，线程安全 HTTP的REQUEST 编程题 Zigzag遍历矩阵得到的序列，求原矩阵（反序列化） 剑指offer，把数组的数排成最小（最大的数） 面试预习[2019.3.6] 根据牛客的C++面经： 有了解多态吗？ 多态是C++的一种特性，同一个接口可以对不同类型提供不同的实现方法，可以达到接口重用的目的。 在C++里面主要分为两种，一个是静态多态，一个是动态多态。静态多态通过在定义重载函数来实现，在编译时可以确定具体调用的是哪个重载的实现【具体过程为函数匹配，参考/C++/语句与函数】。 对于动态多态，对基类中声明虚函数然后派生类可以定义各自的虚函数实现，通过使用基类指针或引用调用虚函数来达到多态。编译时可以确定指针或者引用的静态类型（基类类型），运行时才能知道指针指向或引用的对象的实际类型，根据类型选择函数（动态绑定）。【引申下一个话题】 虚函数的实现，虚函数表指针是类所有还是对象所有，虚函数表呢？ 通过让每个类维护一个虚函数表，里面存储函数指针指向这个类的虚函数地址，虚函数表是类共有的。对象拥有一个虚函数表指针，是在构造函数运行时初始化，指向所属类的虚函数表。 虚函数实现的过程是：通过对象内存中的虚函数指针vptr找到虚函数表vtbl，再通过vtbl中的函数指针找到对应虚函数的实现区域并进行调用。所以虚函数的调用时由指针所指向内存块的具体类型决定的。 auto关键字有用过吗？ 可以不指明变量的类型，让编译器自动推断表达式的类型。通常会忽略顶层const，保留底层const 【拓展】decltype：选择并返回表达式的类型，且返回变量类型（包括顶层const，引用） 手写二分查找 ​ 结构体内存对齐，给一个结构体让分析 https://zhuanlan.zhihu.com/p/26122273 TCP和UDP的区别？两个进程在使用TCP通信，如何检测对方进程没有挂掉。 ​ MTU是什么 最大传输单元，IP包在传输时需要根据链路上的MTU判断是否需要分片 C语言的宏定义函数怎么用 #define add(a,b) a+b //错误 #define add(a,b) ((a)+(b)) //正确 #define由预编译器处理，直接执行替换原来的式子，若不加括号遇到更高优先级的操作符会出现意料之外的结果 拷贝构造函数的const和引用有什么用？ 拷贝构造函数需要引用 Sales_data::Sales_data(const Sales_data &orig){} 若不引用，则此处值传递，又会调用拷贝构造函数，如此循环，没法完成拷贝构造 Sales_data::Sales_data(Sales_data &orig){} const Sales_data a; Sales_data b = a; //错误 a是 const类型 若不使用const类型，则无法使用常量变量进行拷贝构造。此外由于引用，使用const可以保证不修改引用的对象。 什么时候会出现重载 当调用函数时，在调用点可见的作用域内有多个形参列表不同、名字相同的函数时，会出现函数重载。由编译器负责选择具体的重载版本，根据实参的类型 STL有用过吗，map用过没有？ vector用的多，可能深入展开为vector的增长模式？ map待补充 C ++11有了解哪些 列表初始化 范围for auto关键字 nullptr关键字 日常最常用的C ++技术有哪些 用的多的是new、stl的vector 一个项目里最深刻的一点 又问了一下多态和虚函数，虚函数表（这个是中间问的问题） C ++11和boost库用过哪些 STL用过哪些，vector最多可以申请多大内存。 C ++的异常有哪几种？ Windows下DLL需要多加哪些语句。 让你写一个线程池需要写什么功能。【？】 vector是线程安全的吗？用什么可以保证vector的线程安全。【？】 有哪些实现同步的方式，如何确保线程释放锁。【？】 第二个牛客面经 https://www.nowcoder.com/discuss/22775 C++ 里面的static作用，const作用 写一个接口，刚开始没太懂，后来我写了一个抽象基类带了一个纯虚函数 写一个比较大小的模板函数 写一个单例模式的类 写vector的扩容过程 STL 里面的数据结构 C++11 里面的智能指针有哪些，区别是什么 TCP建立连接过程的具体函数调用 凉经 CPU和GPU的区别？ 设计目的【ST】 硬件结构区别【A】 特点【R】 为什么使用多线程CPU/GPU 任务本身特点出发，计算密集型，可分成子任务，无依赖【Situation】 速度是瓶颈【Task】 多线程CPU/GPU带来的好处【Action】 效果【Result】 了解什么c++11特性 答：auto、大括号初始化。【应该提及：智能指针、nullptr、range for】 auto的实现 编译时，推断表达式的类型，以作为变量类型。必须被初始化否则无法推断 大括号list，为什么要设计这个特性 智能指针 标准库和STL区别 答：不知道C++标准库，C++ Standard Library，是类库和函数的集合，由c++标准委员会制定，并不断维护更新。标准程序库提供若干泛型容器、函数对象、泛型字符串和流（包含交互和文件I/O），支持部分语言特性和常用的函数，如开平方根。C++标准程序库也吸收了ISO C90 C标准程序库。标准程序库的特性宣告于std名字空间之中。std命名空间是C++中标准库类型对象的命名空间STL（标准模板库，英文：Standard Template Library，缩写：STL），是一个C++软件库，大量影响了C++标准程序库但并非是其的一部分。其中包含4个组件，分别为算法、容器、函数、迭代器。实现了基于模版的数据结构和算法。联系：标准库大量参考了并基于标准模板程序库（STL）所创建的习惯用法，包含容器、算法、迭代器、函数对象等。参考：WIKI：C++标准库，WIKI：STL，C++标准库/STD/STL等的区别 项目为什么使用GPU？ CUDA与C区别 CUDA是一种平台，同样也包括编程语言（CUDA C，CUDA C++，CUDA FORTRAN）CUDA C/C++，拥有自己的语法，对于CUDA C/C++它支持C++的子集参考：stackoverflow:Cuda C and C++ vector的内存管理。内存占用，如果一开始10000个元素缩小到100，内存会变化吗？一个100元素vector和10000个元素的占用。如何调整vector的空间。 静态链接 动态链接 答：不清楚参考，待补充 动态库b依赖静态库a，程序c依赖动态库b，编译结果会怎样 程序与进程区别，编译过程 同上待补充 网络，TCP和UDP的区别，拥塞控制算法流程 inline 介绍，优势。效率高，为什么开销低。减少函数栈的开销，还有呢？不知道。 内联函数更快，因为您不需要在堆栈上推送和弹出内容，如参数和返回地址。避免参数拷贝 可重用，减少代码重复，且修改方便。本身是一个函数，会检查参数问题，更安全（可与#define宏相比） 内联函数应该在头文件中定义，这一点不同于其他函数。编译器在调用点内联展开函数的代码时，必须能够找到 inline 函数的定义才能将调用函数替换为函数代码，而对于在头文件中仅有函数声明是不够的。 参考：stackoverflow:Benefits of inline function in C++ ，When use Inline 会不会多线程，什么时候用多线程，单核心单线程的机器跑多线程会怎么样？ 应该展开讲，思维局限在了高性能应用中 考虑非计算密集型任务【阻塞等情况，交互型】，以及计算密集型任务。考虑OS “有些人把多线程的程序设计和多处理器或多核系统联系起来. 但是即使程序运行在单处理器上, 也能得到多线程编程的好处. 处理器的数量和并不影响程序结构, 所以不管处理器的个数多少, 程序都可以通过使用多线程得到简化. 而且, 即使多线程程序在串行化任务上不得不阻塞, 由于某些线程在阻塞的时候还有另一些线程可以运行, 所以多线程程序在单处理器上运行还是可以改善响应时间和吞吐量。 知乎：单核心CPU的多线程 介绍openmp。 【是什么】【有什么用】【好处】 OpenMP是一个可移植跨平台的多线程实现，主线程(顺序的执行指令)生成一系列的子线程，并将任务划分给这些子线程进行执行。这些子线程并行的运行，由运行时环境将线程分配给不同的处理器 抽象程度高、易于编程，帮程序员接管负载均衡的问题。可以实现任务并行和数据并行。 用法，#pragma。 参考：OMP入门，Wiki:OMP 两个线程都调用cout，线程1输出A，线程2输出B，输出结果？手写多线程，两个线程轮流cout，保证结果轮流。 写一个空类 class A{}; 大小？ C++标准指出，不允许一个对象（当然包括类对象）的大小为0，不同的对象不能具有相同的地址。这是由于：new需要分配不同的内存地址，不能分配内存大小为0的空间避免除以 sizeof(T)时得到除以0错误 参考：C++空类大小 new malloc区别 智能指针，unique_ptr能赋值给别人吗 循环引用(weak_ptr解决shared_ptr的循环引用问题) Class struct区别 C程序内存模型 线程进程区别 手撸atoi "}}