{"./":{"url":"./","title":"ReadMe","keywords":"","body":" 为保证阅读效果，建议转跳到Gitbook或GithubIO C++ 表达式 expression 语句 statement & 函数 function Data structure and algorithm 二叉树 排序算法 Computer network 基本定义 TCP/UDP "},"C++/biao-da-shi.html":{"url":"C++/biao-da-shi.html","title":"表达式 expression","keywords":"","body":"概念： 表达式 expression， 对表达式求值得到一个结果，字面值和变量是最简单的表达式。把一个运算符与一个或多个运算对象组合起来可以得到复杂表达式 运算对象 operand 运算符 opeartor：一元unary、二元binary 组合运算符与运算对象，多个运算符的表达式，需要考虑优先级、结合律、求值顺序 运算对象转换，将运算对象从一个类型转为另一个类型 重载运算符，无法改变优先级、结合律、运算对象个数 左值与右值 左值表达式：求值结果是一个对象或者函数。 对象用于右值时，用的是对象的值（内容），用做左值时，用的是对象的身份（在内存中位置）。 左值可代替右值使用，反之不行 优先级，结合律，求值顺序 优先级：哪个运算符先组合（eg. *优先级比+高） 结合律：左结合律，则相同运算符从左到右开始顺序组合（eg. std::cout>>i1>>i2>>endl; >>是左结合律） 括号无视组合规则 求值顺序：大多数情况不明确表达式中运算对象的求值顺序。 4个运算符规定求值顺序：逻辑与（&&）、逻辑或（||）、逗号（,）、条件运算符（?:） Int i = f1()*f2(); //不确定发f1与f2的调用顺序； std::cout 例 f()+g()*h()+j(); 优先级：g()返回值先与h()返回值相乘 结合律：f()返回值先于g()*h()返回相加，结果再与j()返回值相加 求值顺序：这些函数调用顺序无明确规定 运算符 算数运算符 除非特殊说明，能用于任意算数类型；运算对象、求值结果都是右值。 取模、取余运算，几个特点： 若商运算两个运算对象符号相同，则结果为正数 C++11规定商向0取（切除小数部分） 取余的运算对象都为整数类型 (m/n)*n + m%n == m，即m%n若不为0则与m同号 逻辑和关系运算符 与、或：左侧为真时才计算右侧对象（短路求值 short-circuit evaluation） 关系运算符（>,>=,） 进行比较运算时除非比较对象是bool，否则不使用bool字面值true和false 赋值预算符 左侧运算对象必须是可修改的左值，结果也是左侧运行对象的左值。满足右结合律 C++11允许花括号初始化 vector vi={1,2,3,4,5}; 递增、递减运算符 前置版本：以左值形式返回对象本身 后置版本：以右值形式返回对象原始值副本（非必要时不用，由于副本存在可能影响性能） 成员访问运算符 指针类型ptr，ptr->mem等价于(*ptr).mem 箭头运算符->，结果是左值 点运算符.，若成员是左值则结果为左值，反之为右值 条件运算符?: 可嵌套，右结合律，从右到左组合。 优先级低，长表达式中嵌套了条件运算符子表达式，通常需要加括号 位运算符 ~ 位求反 左移 >> 右移 & 位与 \\ 位或 ^ 位异或 左移/右移，右侧运算对象不能为负值且不可超过结果位数，移出界外的值舍弃 左移运算符右侧用0填充，对于无符号/有符号类型一样 右移运算符>>的左侧填充bit与类型有关：无符号类型填充0，有符号类型根据实现不同或填充0或填充符号位（微软的实现中填充符号位） https://docs.microsoft.com/en-us/cpp/cpp/left-shift-and-right-shift-operators-input-and-output?view=vs-2017 移位运算符（IO运算符） cout 重载版本常用于IO操作，结合律优先级与原来一样。 左结合律，返回左值。运算优先级比关系、赋值、条件运算符的优先级高。 sizeof运算符 右结合律，返回size_t类型的常量表达式 并不实际计算运算对象的值，因此对无效指针p运算的size(*p)是安全的 逗号运算符 含有两个运算对象，按从左到右求值。先求左侧表达式的值，并抛弃求值结果，真正结果是右侧表达式的值（若右侧表达式运算对象是左值，则求值结果也算左值） 类型转换 算术转换 整型提升：小整数类型转换为大整数类型，保证提升为能容纳原类型所有可能的值的大类型 无符号类型的运算对象：运算对象的类型不一致，需转为同一种类型。先整型提升，若匹配无需进一步转换。若一个为有符号、另一个为无符号，只有无符号的对象的所有可能值可以被有符号类型容纳，才将无符号对象转换为有符号类型（其他情况将有符号对象转为无符号类型）。 例： short sval; char cval; int ival; long lval; unsigned short usval; unsigned int uival; sval + cval; //sval和cval提升为int usval + ival; //根据unsigned short 和 int所占空间大小进行提升 uival + lval; //根据unsigned int 和 long所占空间的大小进行转换 其他类型隐式转换 数组转换为指针。当数组用作decltype、sizeof、&取址符、typeid时，不发生以下转换。 int ia[10]; int *ip = ia; 整数0、字面常量值nullptr能转换为任意指针类型；指向任意非常量的指针能转换为void*；指向任意对象的指针能转换成const void*。 显式转换 强制类型转换 cast-name(expression); //cast-name为 static_cast、dynamic_cast、const_cast和 reinterpret_cast Dynamic_cast：支持运行时类型识别 Static_cast：任何具有明确意义的类型转换，只要不包含底层const都可用。可用于较大算数类型转换为较小类型、void*转换为其他类型指针 Const_cast：只能改变运算对象的底层const const char *pc; char *p = const_cast(pc); //正确，但通过p写值是未定义行为 "},"C++/yu-ju-statement-and-hanshu-function.html":{"url":"C++/yu-ju-statement-and-hanshu-function.html","title":"语句 statement & 函数 function","keywords":"","body":"语句 空语句 ;//空语句 复合语句 花括号括起来的语句和声明序列，也称为块 范围for 不能通过范围for向vector等对象增加元素，因为预存了end的值，可能失效。 for (auto &r : v) r *= 2; //等价于 for(auto beg = v.begin(), end=v.end(); beg!= end; ++beg){ auto &r = *begin; r *= 2; } try语句 try{ program-statements } catch (exception-declaration){ handler-statements } catch (exception-declaration){ handler-statements } //.. 函数 形参（parameter） 实参（argument）：形参的初始值，实参求值顺序不规定。 调用运算符（call operator）: () 函数调用完成两项工作 用实参初始化形参（隐式定义并初始化 将控制权转交给被调用函数（主函数此时被暂时中断）。 return语句结束函数执行过程，完成两个工作： 返回return语句中的值（若有） 将控制权从被调函数转回主调函数。不能返回数组、函数，但可以返回指向数组或者函数的指针 局部对象与生命周期 名字有作用域（在其中可见） 生命周期是该对象存在的一段时间 局部对象：形参、函数体内部定义的变量，为局部对象（local variable） 自动对象：函数控制路径经过变量定义语句时创建，块尾部销毁。只存在于块控制期间的对象为自动对象。形参为实参初始化的自动对象，对于自动对象若无初始值则默认初始化。 局部静态对象（Local static object）：生命周期贯穿函数调用及之后的时间。在执行路径第一次经过对象定义语句时初始化，程序结束时销毁。 分离式编译 修改了其中一个源文件，只需要重新编译那个改动了的文件。产生后缀为.obj(Win)或.o(UNIX)的文件，含义为该文件包含对象代码(object code)。 编译器将对象文件链接成可执行文件 内联函数 在每个调用点上“内联地”展开，避免调用开销。 #向编译器发出请求，编译器可以拒绝 constexpr函数 能作用于常量表达式的函数 约束： 返回类型和所有形参的类型都得是字面值类型； 有且只有一条return语句 #编译器把对constexpr函数的调用替换成结果值，为了能在编译过程中展开，constexpr函数被隐式地指定为内联函数 允许constexpr函数返回值并非常量。（例，写为，用非常量表达式调用返回非常量表达式，用常量表达式调用返回常量表达式） 内联函数和constexpr函数可以多次定义，必须完全一致（展开函数需要其定义）。通常定义在头文件中。 函数参数传递 实参对形参初始化。 形参为引用类型，则绑定到对应实参（引用传递）；否则值拷贝后赋值给形参（值传递）。 const形参和实参 实参初始化形参时忽略顶层const。形参为const时，传给它常量或非常量都可以。 void fcn(const int i) {} void fcn(int i){} //错误，重复定义func(int) 虽然函数可以重载，但是形参列表应该有区别。上述两个函数参数可以完全一样，因此第二个定义有错。（guess：顶层const无法重载.？） 指针或引用形参与const 可以用非常量初始化底层const，反之不行。 只有引用传递和指针传递可以用是否加const来重载。 尽量使用常量引用 传入参数限制：普通引用无法传入const对象。 适应性：其他函数正确定义const引用，但非常量引用的函数无法在其中调用 数组形参 数组特点：不允许拷贝数组、使用时通常转换为指针 无法值传递，传递时数组会被转换为指针，数组大小无影响。 形参可写为： void print(const int*); void print(const int[]); void print(const int[10]); //表示期望数组的元素数目，但实不一定如此 上述三个函数等价，形参都为 const int*，传入时只检查参数是否为const int *。 指定数组大小 用标记指定数组结束，如字符数组的'\\0'，读到表示数组结束 使用标准库规范：传入数组首元素、尾后元素的指针 显式传递数组大小 数组引用形参和const 变量（形参）可定义为数组的引用 //正确：形参是数组的引用，维度是类型的一部分 void print(int (&arr)[10]){ for (auto elem : arr) cout 数组大小是构成数组类型的一部分，不超过维度都可在函数体内使用。 当不需要对数组元素执行写操作时，形参应该为指向const的指针。 多维数组 C++没有真正意义的多维数组，是数组的数组。 传递多维数组时，传递的是指向数组首元素的指针。 //matrix指向数组的首元素，该数组的元素是由10个整数构成的数组。matrix括号不可忽略！ void print(int (*matrix)[10], int rowSize){}; 也可以使用数组语法定义，第一个维度会被忽略因此不适宜放在形参列表中 //等价定义 void print(int matrix[][10], int rowSize){}; 可变形参的函数 使用initializer_list标准库类型 特殊形参类型：省略符。一般只用于与C函数交互的接口 默认实参 可以为形参提供默认实参，作为初始值出现在形参列表中。 一旦某个形参被赋予默认值，它后面所有形参必须有默认值。 默认实参声明 一个函数可以声明多次，但给定作用域中，一个形参只能被赋予一次默认实参。 同一个函数的后续声明，只能为之前没有被赋予默认值的形参添加默认实参，且形参右侧的所有形参必须有默认值。 局部变量不能作为默认实参（即，全局变量可以）。表达式的类型能转换为形参所需类型也可以。 默认实参名字在函数声明所在的作用域内解析，求值过程发生在函数调用时。（即，默认实参为某个全局变量，调用时求全局变量值（可能会在运行时发生改变）） 返回类型与return语句 返回值的方式和初始化形参、变量的方式一样：返回值用于初始化调用点的一个临时量，临时量就是函数调用的结果。 返回引用，引用为所引对象的别名。因此，不返回局部对象的引用或指针。若返回引用得到左值，其他返回类型得到右值。 const string &manip(){ //局部变量 string ret; //某些处理ret if(!ret.empty()) return ret; //错误：返回局部对象引用 else return \"Empty\"; //错误：\"Empty\"是一个局部临时量 ｝ 列表初始化返回，用花括号初始化。 vector process(){ // ... return {\"functionX\",\"Okay}; } 返回数组指针 数组特点：不可拷贝，因此可以返回数组指针或引用。 声明一个返回数组指针的函数： int arr[10]; int *p1[10]; //含有10个指针的数组 int (*p2)[10] = &arr; //指向含有10个整型的数组的指针 若要返回一个数组指针，数组维度必须跟在函数名字之后。形参也跟在函数名前且先于数组维度。 Type (*function(parameter list)) [dimension]; int (*func(int i))[10]; //使用类型别名代替 typedef int arrT[10]; using arrT = int[10]; arrT* func(int i); 使用尾置返回类型（C++11）【也可使用decltype】 auto func(int i) -> int(*)[10] 主函数main 可以没有return语句，编译器隐式插入返回0的return语句。 不可调用自己 递归：直接、间接调用自己 函数重载 同一个 作用域内，几个函数名字相同但形参不同，称之为重载函数 #main函数不能重载 #不允许两个函数除了返回类型外，其他要素相同 重载与const形参 如上所述，顶层const不影响传入函数的对象。一个有顶层const的形参无法与另一个无顶层const的形参区分。 int func(int); int func(const int); //重复声明 int func_(int*); int func_(int* const); //顶层const,重复声明 底层const可以实现重载 int func(int &); int func(const int &); //合法重载，常量引用 int func_(int*); int func_(const int*); 底层const只能传给const。由于非常量可以转换为const，非常量引用、指向非常量的指针可以作用于以上四个函数，在调用时，编译器将非常量的参数优先调用非常量的重载函数。 const_cast与重载 //常量引用版本 const string &shorter_string(const string &s1, const string &s2){ return s1.size()(s1), const_cast(s2)); return const_cast(r); } 调用重载的函数 函数匹配（function matching），又叫重载确定（overload resolution） 把函数调用与一组重载函数中的某一个关联起来。将调用的实参与重载集合中的每一个函数的形参进行比较，再根据比较结果决定调用哪个： 找到一个与实参最佳匹配的（best mtach）的函数，生成调用的代码。 找不到任何一个匹配，编译器发出无匹配（no match）的错误。 有多于一个的函数可以匹配，但每一个都不是明显更好的选择。发生错误，二义性调用（ambiguous call） 重载与作用域 如果在内层作用域声明名字，将隐藏外层作用域中的同名实体。不同作用域中无法重载。 #C++中，名字查找发生在类型检查之前。 函数匹配 "},"Data-structure-and-algorithm/er-cha-shu.html":{"url":"Data-structure-and-algorithm/er-cha-shu.html","title":"二叉树","keywords":"","body":"树的递归定义 树为节点集合，若节点非空，则有由一个根节点和0个或多个非空的（子）树组成，每个子树的根都被来自根r的一条有向边所连接。 树叶、兄弟、父亲、祖先、后裔 路径：从节点n1到nk的path定义为节点n1,n2,n3,…,nk的一个序列：使得1 深度：根到ni的唯一路径的长，（根的深度为0） 高度：ni到一片树叶的最长路径的长。所有树叶高度为0，一棵树的高等于根的高 内部路径长：所有节点的深度。 遍历二叉树（traversal） BFS，队列 按层：往往要求获取层数信息（维护两个last变量，一个指向当前层，一个指向下一层） https://leetcode.com/problems/binary-tree-level-order-traversal DFS，栈 递归的函数上下文栈，或者循环+栈。递归简单清晰，应练习非递归的循环遍历方法 先序遍历(pre-order)：遍历顺序：节点->左儿子（子树）->右儿子（子树） https://leetcode.com/problems/binary-tree-preorder-traversal/ 中序遍历(in-order)：左儿子（子树）->节点->右儿子（子树） 有意思的是，将N个点插入到二叉查找树，再执行中序遍历输出N个点的排序结果。（从中序遍历和二叉查找树的定义可理解，复杂度为O(NlogN)O(NlogN)O(NlogN)） https://leetcode.com/problems/binary-tree-inorder-traversal/ 后序遍历(post-order)：左儿子（子树）->右儿子（子树）->节点 https://leetcode.com/problems/binary-tree-postorder-traversal/ （先序）序列化： 加入空字符#、结束字符！ 反序列化： 由输入字符串->vector \"12!3!#!#!#!\" -> [\"12\",\"3\",\"#\",\"#\",\"#\"] 二叉查找树：Binary search tree 定义：每个节点都有其关键字值，对于树中每个节点X，其左子树中所有节点关键字值都小于X的，右子树所有节点的关键字值都大于X的。 树的任意点期望深度为O(logN)O(logN)O(logN)，平均操作【insert, find, findmin, findmax, delete】复杂度为O(logN)O(logN)O(logN)。 删除操作会破坏这种平均特性，由于删除时，把右子树的最小节点代替原节点，有助于使得左子树比右子树更深。 已证明，交替插入删除Θ(N2)\\Theta(N^2)Θ(N​2​​)次，期望深度将为Θ(N)\\Theta(\\sqrt N)Θ(√​N​​​)。 可通过交替选取右子树最小、左子树最大元素来代替被删节点来消除。 若向预先排序的树输入数据，一连串insert花费二次时间，链表实现代价很大，树由那些没有左儿子的节点组成。 解决方法：附加条件“平衡” AVL树 带平衡条件的二叉查找树，保证树深度为O(logN)O(logN)O(logN) 定义：每个节点的左子树和右子树的高度最多差1的二叉查找树。（空树高度为-1） 插入可能破坏条件，通过“旋转”来修正。插入之后，只有插入点到根节点的平衡可能被改变（只有这些节点的子树可能发生改变），沿此路径上行并更新平衡信息。 旋转操作： 找出第一个破坏AVL条件的节点α（最深的节点），并重新平衡。 四种情况（WHY？，α的左右子树高度差4，若插在左/右儿子则高度差不可能为2，α不可能为第一个破坏点）： 对α的左儿子的左子树插入 对α的左儿子的右子树插入 对α的右儿子的左子树插入（与2.对称） 对α的右儿子的右子树插入（与1.对称） 通过单旋转、双旋转来解决。实现可递归定义插入、左/右的单/双旋转。 单旋转（左-左/右-右） 双旋转（左-右/右-左） 伸展树（Splay Tree） 放弃平衡条件，允许任意深度，但每次操作之后调整； 连续M次操作平均最坏情况O(MlogN)O(MlogN)O(MlogN)，无法保证任意一次操作花费O(N)O(N)O(N)的可能。 对于二叉查找树最坏情况 O(N)O(N)O(N)，若要求最差情况O(MlogN)O(MlogN)O(MlogN)则节点被访问之后必须被移动，否则一直访问最坏节点则有O(MN)O(MN)O(MN) 基本想法：当一个节点被访问后，经过一系列AVL树的旋转被构造到根节点。若该点很深，则路径上的许多存在节点也相对比较深，重新构造可以使得对这些节点的访问时间变少。（实际上，一个节点被访问之后，可能不久再次被访问） 不保留高度或平衡信息 平衡方法 直接单旋转，对最坏情况复杂度为O(MN)O(MN)O(MN) ，因此不可行。 展开操作：XXX为目标节点，若其父为根节点，直接单旋转。否则分为以下情况 之字形（Zig-zag），即采用AVL的双旋转 一字型（Zig-zig） B-Tree 定义：B-树是平衡M-路树；对于阶为MMM的B-树，有如下 树的根，或为叶子节点，或有222到MMM个儿子 除了根以外，所有非叶子节点（内部节点）的儿子数在⌈M/2⌉\\lceil M/2\\rceil ⌈M/2⌉和MMM之间。 所有树叶在相同深度上，所有的数据都存储在树叶上。（数据本身，或指向数据的指针） 在每一个内部节点上，有如下： 指针：指向该节点的各个儿子（子树），P1P_1P​1​​,P2P_2P​2​​,P3P_3P​3​​,...,PMP_MP​M​​ 内部信息：分别代表子树P2P_2P​2​​, P3P_3P​3​​,...,PMP_MP​M​​中发现的最小关键字的值，k1k_1k​1​​,k2k_2k​2​​,k3k_3k​3​​,...,kM−1k_{M-1}k​M−1​​。（第一个子树由于在最左侧，没有比它更小的子树，因此不需要存储它的最小关键字值） 例：3阶B-树（又称为2-3树） 图例：椭圆为内部节点，椭圆内的数表示内部信息（子树的最小关键字值）。方框为树叶，其中数字表示关键字的值（此处为数据）。 由于最左侧的子树的最小关键字值是不需要存储的，有n个儿子的情况下只需存储n-1个值。因为是3阶的B-树，对于三个儿子的情况需要存储2个内部信息值（见节点41:58），对于2个儿子则只需要存储一个信息值（见16:-和22:-）。 插入 对于尚未见过的关键字值XXX执行Insert，先按Find找到一片树叶，插入到该位置。若插入后破坏了B-树性质（树叶包含数据超过MMM），则执行“分裂”，向上一层增加一个节点（若上一层增加后又破坏B-树的性质，则递归向上分裂）。此外，也可以不执行“分裂”，如向上图插入70，可以移动58到左侧树叶。 需要注意，插入时只有访问路径上的内部节点才有可能变化。 复杂度 深度最多为⌈log⌈M/2⌉N⌉\\lceil log_{\\lceil M/2\\rceil}N\\rceil⌈log​⌈M/2⌉​​N⌉ 对于路径上每一个节点，要执行O(logM)O(logM)O(logM)时间的工作来确定分支路线（二分查找） Insert和delete可能还需要O(M)O(M)O(M)的工作量来更新调整节点上的所有信息，因此最坏情况为O(MlogMN)=O((M/logM)logN)O(Mlog_{M}N)=O((M/log_{M})logN)O(Mlog​M​​N)=O((M/log​M​​)logN)，不过一次Find只花费O(logN)O(logN)O(logN) 时间 应用：数据库系统 树存于物理磁盘而非内存。 磁盘访问次数为O(logMN)O(log{M}N)O(logMN)， 虽然要花费O(logM)O(logM)O(logM)时间来确定分支，但仍比读存储器快得多。 每个节点更新花费O(M)O(M)O(M)操作时间，这些花费一般不大（WHY？） MMM值一般选择为，使得一个内部节点能够装入一个磁盘区块的最大值。 存储在一片树叶上的元素的最大个数时，要使得树叶是满的那么它就装满一个区块。 "},"Data-structure-and-algorithm/sort.html":{"url":"Data-structure-and-algorithm/sort.html","title":"排序算法","keywords":"","body":" 常见排序方法 冒泡、选择排序、插入排序、归并排序、快速排序 开始之前 先编写交换元素的函数，以便后续排序时调用。都声明为inline，减少调用开销。 //下标形式的 inline void swap(vector &v, int i, int j){ int tmp = v[i]; v[i] = v[j]; v[j] = tmp; return; }; //迭代器形式的 inline void swap(vector::iterator i1, vector::iterator i2){ int tmp = *i1; *i1 = *i2; *i2 = tmp; return; }; 快速排序 /* * quick sort */ void quick_sort_recursive(vector::iterator beg, vector::iterator end){ if(beg+1 >= end) return; //这里选第一个元素的值作为中间值 //实际上也可以选择其他位置的元素，为了方便修改保留了这个变量。 auto key = beg; auto middle = *key; auto l_end = beg, curr = beg; //swap key and the last exchange_ele(key, end-1); while(curr != end-1){ if(*curr &v){ quick_sort_recursive(v.begin(), v.end()); return; } 堆排序 /* * Heap sort */ void siftdown(vector &v, int i, int len){ //for i (start from 0 to n-1 ) //left : 2*i + 1 //right : 2*i + 2 //father : (i-1)/2 int son = 2*i + 1; if(son>=len) return; if((son+1) v[son] ) ++son; if(v[i]>= v[son]) return; swap(v, i, son); //recursive return siftdown(v, son, len); } void heap_sort(vector &v){ //sift down from the last father to the root //O(N) for(int i=(v.size()-2)/2; i>=0; --i) siftdown(v,i,v.size()); //O(NlogN) for(int i=v.size()-1; i>0; --i){ swap(v,0,i); //the last element swap to the first //then go down. siftdown(v,0,i); } return; } 参考： https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F "},"computer-network/networkbasic-definition.html":{"url":"computer-network/networkbasic-definition.html","title":"基本定义","keywords":"","body":" 计算机网络基本定义 网络：若干节点node（计算机、集线器、交换机或路由器）和连接节点的链路link组成。 互联网：network of networks 因特网：全球最大的互联网 边缘部分：主机组成，用户直接使用 主机A与主机B通信：主机A的某个进程和主机B上的另一个进程通信 端系统之间的通信方式可分为： 客户端（client）-服务端（server）方式：指通信涉及的两个应用进程，客户端请求服务（发起通信），服务端提供服务。 对等连接（peer to peer，P2P）：两个主机通信时不区分谁是服务提供方、请求方。两个主机都运行P2P软件，则平等、对等通信。 核心部分：大量网络和连接网络的路由器组成，为边缘提供服务 路由器，实现分组交换（转发分组，分组为报文的一部分） 按照范围、使用者划分的几个网络定义： WAN（广域网），LAN（局域网），PAN（个人域网） 公用网，专用网 指标 速率：（数据率、比特率）传输数据的速率，bit/s 带宽：最高数据率 吞吐量：单位时间内通过网络的数据量 时延/延迟：发送时延、传输时延、处理时延、排队时延 时延带宽积： = 传播时延x带宽，又称为以比特为单位的链路长度 往返时间RTT：发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间。 利用率：信道利用率、网络利用率（两者不同）。信道或网络利用率过高，会产生很大的延迟。对于网络利用率和延迟的关系，D=D0/(1−U)D=D_0/(1-U)D=D​0​​/(1−U)，其中DDD为延迟，D0D_0D​0​​为空闲时的延迟，UUU是利用率。 协议与层次 规定交换数据的格式以及有关的同步问题 协议是水平的，控制两个对等实体进行通信，使得本层能够向上一层提供服务，使用本层协议需要下一层所提供的服务。下层协议对上面的实体是透明的，只有能被实体看见的才称为服务。 分层 各层独立，灵活性好，结构上可分割开，易于实现和维护，促进标准化工作 各层完成的功能（一种或多种，同一个功能在不同层次可能会反复出现）： 差错控制 流量控制 分装和重装（数据块划分为更小的单位，在接收端将其还原） 复用和分用（几个高层会话复用一条低层连接，在接收端将其还原） 连接建立和释放 模型 五层简介 各层的传输单元都可以称为分组，在OSI模型中成为PDU(Protocol Data Unit) 应用层(application layer) 通过应用进程的交互来完成特定网络应用，应用进程通信和交互的规则【HTTP、SMTP、FTP】 数据单元：报文(message) 传输层(transport layer) 向两个主机中进程之间的通信提供通用的数据传输服务 通用：不针对某个应用，多个应用可使用同一个传输层服务【复用、分用】 TCP(Transmission Control Protocol)面向连接、可靠的数据服务，传输单元：报文段(segment) UDP(User Datagram Protocol)无连接的、尽最大努力(best-offer)的数据传输服务，不保证可靠性，传输单元：用户数据报 网络层(network layer) 为分组交换网的不同主机提供通信服务。发送数据时，把报文段、用户数据报封装为分组或包(packet)进行传送。 TCP/IP中使用IP协议，分组又称为IP数据报，或简称数据报(Datagram) 另一个功能：路由决策，使得传输层接下来分组可以通过网络中的路由器找到目的主机 数据链路层(data link layer) 负责链路上两个相邻节点之间的数据传输（字节流），将IP数据报组装成帧(frame)，帧包括控制信息，以便接收端提取数据给上一层 检错、纠错功能 物理层(physical layer) 提供透明传输比特流的功能， "},"computer-network/networktcp-udp.html":{"url":"computer-network/networktcp-udp.html","title":"TCP/UDP","keywords":"","body":" TCP、UDP是传输层的服务，为应用进程提供通信。 重要概念 传输层为互相通信的应用进程提供逻辑通信（端到端） 端口(port)与套接字(socket) 无连接的UDP，不可靠信道 面向连接的TCP，全双工的可靠信道 在不可靠网络上实现可靠传输的原理，停止等待协议、ARQ协议 TCP的滑动窗口、流量控制、拥塞控制和连接管理 运输层的端口 运输层从IP层收到数据后，需要交付给特定应用进程，因此需要标志运行在应用层的各种应用进程。为了不同OS的应用进程可以互相通信，需要用统一的方法（与OS无关）标志。 协议端口号（端口，port） TCP/IP使用16位的端口（65535个），TCP和UDP的首部都有源端口和目的端口，端口是标志本计算机应用层的各个进程与传输层交互的层间接口，只具有本地意义。通信时需要知道对方IP地址、端口 端口分类 服务器使用端口 熟知端口号、（系统端口号）：0-1023 登记端口号：没有熟知端口的应用程序使用，1024-49151 客户端使用的端口号（短暂端口号） 49512-65535，客户端进程运行时动态选择，暂时使用 UDP 无连接的 尽最大努力交付 面向报文，发送方的UDP对应用程序交下的报文，添加首部后就交付给IP层，不合并也不分拆。一次交付一个完整的报文。 没有拥塞控制，拥塞不会降低发送速率。对于实时的应用，要求主机以恒定速率发送数据，可以容忍丢失但是对延迟敏感，使用UDP。 支持一对一、一对多、多对一、多对多的交互通信 首部开销小（8个字节） UDP的首部格式 每个字段2字节 源端口，不需要对方回信时可全0 目的端口 长度，最小值为8（仅有首部） 校验和 接收方从IP层收到UDP数据报时，根据目的端口分发给应用进程。 若接收方UDP发现收到的报文中的目的端口不正确（不存在对应这个端口的应用进程），则丢弃报文，使用ICMP发送“端口不可达给发送方” 校验和 计算时要加入伪首部，伪首部仅用于计算校验和而不向上或向下传递，计算校验和的部分包括：伪首部、首部、数据部分。同时检查了包括IP数据报源地址、目的地址（伪首部），UDP源端口、目的端口（UDP首部），以及UDP数据部分。 TCP 面向连接的传输层协议：应用使用之前必须先建立连接，传输完毕后必须释放已建立的TCP连接。 每条TCP连接只能有两个端点，是点对点的 提供可靠交付服务 全双工通信，设有发送、接收缓存 面向字节流，TCP的“流”指的是流入到进程或者从进程流出的字节序列 TCP并不关心应用进程一次将多长的报文发送到TCP缓存中，而根据对方给出的窗口值、网络拥塞程度决定一个报文段要包含多少个字节。 TCP的连接 TCP连接的端点是socket 套接字socket=(IP地址:端口号) TCP连接 ::= {socket1,socket2} = {(IP1:port1), (IP2:port2)} 同一个IP地址可以有多个不同的TCP链接，同一个端口号也可以出现在多个不同的TCP连接中 可靠传输 TCP下层不提供可靠传输，需要协议实现： 出现差错时，让发送方重传出现差错的数据。（实际信道会产生差错） 接收方来不及处理数据时，告知发送方降低发送速率。（实际接收方处理速度有限） "}}